<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小黑屋</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kodgv.xyz/"/>
  <updated>2019-08-21T02:58:35.483Z</updated>
  <id>http://kodgv.xyz/</id>
  
  <author>
    <name>KODGV</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA基础</title>
    <link href="http://kodgv.xyz/2019/06/12/JAVA%E5%AD%A6%E4%B9%A0/JAVA%E5%9F%BA%E7%A1%80/"/>
    <id>http://kodgv.xyz/2019/06/12/JAVA学习/JAVA基础/</id>
    <published>2019-06-12T07:59:47.000Z</published>
    <updated>2019-08-21T02:58:35.483Z</updated>
    
    <content type="html"><![CDATA[<p>尚硅谷JAVA基础视频说明</p><a id="more"></a><p>[TOC]</p><h3 id="java简介"><a href="#java简介" class="headerlink" title="java简介"></a>java简介</h3><p>最后再看java的手册</p><p><strong>Java语言的特点</strong></p><ul><li>面向对象</li></ul><p>两个基本概念：类，对象</p><p>三大特性：封装，继承，多态</p><ul><li>健壮性</li></ul><p>吸取了C/C++语言的有点，去掉了影响程序健壮性的部分(如指针，内存的申请与释放等)，提供了一个相对安全的内存管理和访问机制。</p><ul><li>跨平台性</li></ul><p>可以在不同的平台上运行，‘write once,run anywhere’,只要在需要运行java应用程序的操作系统上安装JVM(java virtual machine)即可。</p><p><strong>运行级别：</strong></p><p>.java -&gt; .class -&gt; JVM -&gt; 操作系统 -&gt; 具体硬件</p><p>javac .java 编译为字节码文件.class</p><p>java .class 执行java程序</p><p><strong>注释</strong></p><p>注意多用javadoc，有自己的注释的规范</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>关键字：系统定义的</li><li>标识符：自己起的名字</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 规则：</span></span><br><span class="line"><span class="comment"> * 由26个英文字母，0-9，_,$组成</span></span><br><span class="line"><span class="comment"> * 数字不可以开头</span></span><br><span class="line"><span class="comment"> * 不可以使用关键字和保留字</span></span><br><span class="line"><span class="comment"> * 标识符不能含有空格</span></span><br><span class="line"><span class="comment"> * 规范：</span></span><br><span class="line"><span class="comment"> * 包名：多单词组成所有字母小写 xxxyyyzzz</span></span><br><span class="line"><span class="comment"> * 类名，接口名：多单词组成，所有单词首字母大写 XxxYxxZxx</span></span><br><span class="line"><span class="comment"> * 变量名，方法名：多单词组成，第一个单词首字母小写，第二个单词开始首字母大写 xxxYyyZzz</span></span><br><span class="line"><span class="comment"> * 常量名：所有字母大写，多单词以下划线链接 XXX_YYY_ZZZ</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量定义的格式：数据类型 变量名 = 初始值</span></span><br></pre></td></tr></table></figure><p>变量数据类型</p><p>基本数据类型</p><p>​    数值型</p><p>​        整数类型：byte,short,int,long</p><p>​        浮点数类型：float,double</p><p>​    字符型：char</p><p>​    布尔型：bool</p><p>引用数据类型</p><p>​    类：class</p><p>​    接口：interface</p><p>​    数组：[]</p><p>​    字符串：String(*不是基本数据类型)</p><div class="table-container"><table><thead><tr><th>类型</th><th>占用空间</th><th>表示范围</th></tr></thead><tbody><tr><td>byte</td><td>1字节=8bit</td><td>-128~127</td></tr><tr><td>short</td><td>2字节</td><td>-2^15-2^15-1</td></tr><tr><td>int</td><td>4字节</td><td>-2^31-2^31-1</td></tr><tr><td>long(要声明L)</td><td>8字节</td><td>-2^63~2^63-1</td></tr><tr><td>float(要声明F)</td><td>4字节</td><td>-3.403E38~3.403E38</td></tr><tr><td>double</td><td>8字节</td><td>-1.798E308~1.798E308</td></tr><tr><td>char</td><td>2字节</td><td>所以可以表示一个中文</td></tr><tr><td>boolean</td><td>1字节</td></tr></tbody></table></div><p>注意一下，计算机里面使用补码形式来储存</p><p>值：符号位+值</p><p>反码(原码)：负数符号位+值取反</p><p>补码：负数符号位+值取反+1</p><p>规定：10000000为-128</p><ul><li>超出位会截断，所以它还是-128</li><li>原码-128直接取前8位的补码它也还是-128</li></ul><p>基本变量之间的运算(不含boolean)</p><p>1.自动类型转换：当容量小的数据类型与容量大的数据类型作运算，容量小会自动转为容量大（char,byte,short之间的任何运算都会默认转为int）。</p><p><strong>char,byte,short ===&gt;int ===&gt;long ===&gt;float ===&gt;double</strong></p><p>2.强制类型转换：容量大的转容量小的，要使用强制类型转换符(),会导致精度丢失，它直接截断位数,也可以小转大。</p><p>3.String也不适用(int)等强制转换，它不是基本数据类型，就不适用。</p><p>字符串使用：</p><p>1.char只能是一个字，多了少了都不行。</p><p>2.字符串可以与8种数据类型作运算，包括boolean，而且只能是连接运算（+），结果还是字符串</p><p>复习注意点：</p><p><strong>一定要注意char+char得到的是Int</strong></p><p><strong>char,byte,short之间的任何运算都会默认转为int</strong></p><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>整数有四种表示方式：</p><ul><li>二进制：0,1 满2进1，以0b或0B开头</li><li>十进制：0-9，满10进1</li><li>八进制：0-7, 满8进1</li><li>十六进制：0-9及A-F，满16进1，以0x或0X开头</li></ul><p>二进制：</p><p>计算机内都是以补码的形式存在，它不说一定是补码。</p><p>正数：符号位0，原码反码补码都一致</p><p>负数：符号位1，反码为原码取反，补码为反码+1</p><p>十进制-》二进制：除2取余的逆</p><p>二进制-》十进制：2的次方之和</p><p>二进制-》八进制：3位合一位，反过来就拆开</p><p>二进制-》十六进制：4位合一位，反过来就拆开</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>1.算术运算符</p><ul><li><p>除号是整除，因为Int之间的运算它还是Int，double与Int运算才会自动转换为double</p></li><li><p>%的符号与被模数一致。</p></li></ul><p>2.++/—：前++/—，先自增，后运算</p><p>​        后++/—，先运算，后自增</p><p>​       自增不会改变数据类型</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">int</span> <span class="built_in">a1</span> <span class="number">=10</span></span><br><span class="line"><span class="symbol">int</span> <span class="keyword">b1 </span>= <span class="built_in">a1</span>++//<span class="keyword">b1=10</span></span><br><span class="line"><span class="keyword">byte </span><span class="built_in">a2</span> = <span class="number">127</span></span><br><span class="line"><span class="symbol">a2</span>++</span><br><span class="line"><span class="symbol">a2</span> //-<span class="number">128</span>,因为越界了</span><br></pre></td></tr></table></figure><p>3.赋值运算符</p><ul><li>当两侧数据类型不一致可以使用自动类型转换或强制类型转换原则</li><li>支持连续赋值</li><li>+=，-=，/=，%=：<strong>不会改变数据类型</strong>，因为它加的1是原来数据类型(保险)</li><li>赋值符的返回值为右边赋的值，并不是一直为true</li></ul><p>4.比较运算符</p><p>==  != &gt; &lt; &gt;= &lt;= instanceof</p><p>5.逻辑运算符</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/1" alt="1560848303360"></p><p>短路与和短路或：在满足一个条件后，会短路后面的条件就不执行了</p><p>6.位运算符</p><p>针对二进制进行移动 </p><p><img src="/2019/06/12/JAVA学习/JAVA基础/3" alt="1561203328280"></p><p><img src="/2019/06/12/JAVA学习/JAVA基础/2" alt="1561203269110"></p><p>最高效的2*8 ：2&lt;&lt;3</p><p>最高效的交换：使用^位运算符</p><p>num1 = num1 ^num2</p><p>num2 = num1 ^num2</p><p>num1 = num1 ^num2 </p><p>7.三元运算符</p><p>[条件表达式]？表达式1：表达式2    ==》可以嵌套三元运算符</p><p>8.运算符优先级</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>循环结构4个要素：</p><p>1.初始化条件</p><p>2.循环条件</p><p>3.循环体</p><p>4.迭代条件</p><p>for </p><p><img src="/2019/06/12/JAVA学习/JAVA基础/4" alt="1561279398862"></p><p>while</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/5" alt="1561279490873"></p><p>do while（至少执行一次循环体）</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/6" alt="1561279942319"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组：多个相同类型数据按一定顺序排列的集合</p><p>特点：</p><ul><li>数组属于引用类型变量，数组的元素可以是基本数据类型也可以是引用数据类型</li><li>创建数组会在内存中开辟一整块连续的空间</li><li>数组的长度一旦确定，就不能修改</li></ul><p>知识点：</p><ul><li>如何声明</li><li>如何赋值</li><li>如何遍历</li><li>默认初始化</li><li>内存解析</li></ul><p>1.静态初始化：数组初始化和数组元素的赋值同时进行</p><p>2.动态初始化：数组初始化和数组元素的赋值操作分开进行</p><p>数组下标从0开始，.length获取其长度</p><p>默认初始化值：</p><ul><li>整型（byte,short,int,long）0</li><li>浮点型（float,double）0.0</li><li>字符型（char) 0，或’\u0000’</li><li>布尔型(boolean)false</li><li>引用数据类型 null</li></ul><p>内存解析：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;；</span><br><span class="line"><span class="keyword">String</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">String</span>[<span class="number">4</span>]；</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"刘德华"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"张学友"</span>;</span><br><span class="line">arr1 = <span class="keyword">new</span> <span class="keyword">String</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>方法内的变量都是局部变量</p><p>栈结构：存放局部变量</p><p>堆结构：存放new对象</p><p>局部变量记录堆结构的首地址以此来作为指针指向，当没有被指向的堆结构会采用引用计数法进行垃圾回收。</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/7" alt="1562059760332"></p><p>多维数组：</p><p>从底层实现来看，没有所谓的多维数组。</p><p>声明与赋值：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[<span class="string"></span>][<span class="symbol"></span>] arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;1,2,3&#125;&#125;</span><br><span class="line">int[<span class="string"></span>][<span class="symbol"></span>] arr2 = new int[<span class="string">2</span>][<span class="symbol"></span>]</span><br><span class="line">int[<span class="string"></span>][<span class="symbol"></span>] arr22 = new int[<span class="string">2</span>][<span class="symbol">3</span>]</span><br></pre></td></tr></table></figure><p>数组长度：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1<span class="selector-class">.length</span> <span class="comment">//外层长度</span></span><br><span class="line">arr1[<span class="number">1</span>]<span class="selector-class">.length</span> <span class="comment">//内层长度</span></span><br></pre></td></tr></table></figure><p>内存解析：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[<span class="string"></span>][<span class="symbol"></span>] arr = new int[<span class="string">4</span>][<span class="symbol">3</span>]</span><br><span class="line">syso(arr[0]) //地址</span><br><span class="line">syso(arr[<span class="string">0</span>][<span class="symbol">0</span>])//0</span><br><span class="line">---------------------------------------</span><br><span class="line">String[<span class="string"></span>][<span class="symbol"></span>] arr = new String[<span class="string">4</span>][<span class="symbol"></span>]</span><br><span class="line">syso(arr[0]) //null</span><br><span class="line">syso(arr[<span class="string">0</span>][<span class="symbol">0</span>]) //空指针报错</span><br></pre></td></tr></table></figure><p><img src="/2019/06/12/JAVA学习/JAVA基础/8" alt="1562142578358"></p><p>提示：</p><p>直接打印char数组不会输出地址，因为java print语句对char数组单独写了重载函数</p><p>数组操作的封装类：java.util.arrays 有toString,compare等等有用的数组操作封装</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="学习主线"><a href="#学习主线" class="headerlink" title="学习主线"></a>学习主线</h3><p>1.Java类及类的成员，属性，方法，构造器，代码块，内部类</p><p>2.面向对象的三大特征：封装性，继承性，多态性</p><p>3.其他关键字：this,super,static,final,abstract,interfrace,package,import</p><h3 id="类基本结构-属性-方法"><a href="#类基本结构-属性-方法" class="headerlink" title="类基本结构-属性+方法"></a>类基本结构-属性+方法</h3><p>Field = 属性=成员变量=域，字段</p><p>Method=成员方法=函数=method</p><p>创建类的对象=类的实例化=实例化类</p><p><strong>内存解析</strong></p><p><img src="/2019/06/12/JAVA学习/JAVA基础/9" alt="1562316984064"></p><p>函数内部是局部变量，在栈中</p><p>类内部变量在堆中</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/10" alt="1562322246509"></p><p>属性与局部变量的对比</p><p><strong>1.相同点</strong></p><p>​    <strong>1.1</strong> 定义变量的格式 数据类型 变量名 = 变量值</p><p>​    <strong>1.2</strong> 先声明后使用</p><p>​    <strong>1.3</strong> 变量具有对应的作用域</p><p><strong>2不同点</strong></p><p>​    <strong>2.1</strong> 声明的位置不同</p><p>​        属性：直接定义在类的一对{}内</p><p>​        局部变量：声明在方法内，方法形参，代码块内，构造 器形参，构造器内部的变量</p><p>​    <strong>2.2</strong> 权限修饰符</p><p>​    <strong>2.3</strong> 默认初始化值</p><p>​    属性：类的属性，根据其类型，都有默认初始化值</p><ul><li>整型（byte,short,int,long）0</li><li>浮点型（float,double）0.0</li><li>字符型（char) 0，或’\u0000’</li><li>布尔型(boolean)false</li><li>引用数据类型 null</li></ul><p>​    局部变量：必须赋值    </p><p><strong>方法</strong></p><p>方法:描述类应该具有的功能</p><p>声明：权限修饰符 返回值类型 方法名(形参){方法体}</p><ul><li><p>权限修饰符：public,private,缺省,protected</p></li><li><p>返回值：需要使用return关键字返回指定类型的变量或常量</p></li><li><p>方法名：属于标识符，遵循标识符规范，“知名知义”</p></li><li><p>形参列表：方法可以有0或多个形参  格式为(数据类型1  形参1，数据类型2 形参2)</p></li><li><p>方法体：方法功能的体现，可以调用当前类的属性和方法，不可以再声明方法</p></li></ul><p><img src="/2019/06/12/JAVA学习/JAVA基础/11" alt="1562485502475"></p><p><strong>匿名对象</strong></p><p>定义：创建的对象，没有显示的赋给一个变量名</p><p>特征：匿名对象如果没有赋变量名则只能调用一次</p><p><strong>函数重载</strong></p><p>定义：两同一不同    《==》方法名+参数列表确定唯一方法</p><p>同一个类的同名方法，参数个数或类型或顺序不同。</p><p>跟方法权限修饰符，返回值类型，形参变量名都没有关系</p><p><strong>可变形参</strong></p><p>1.格式：数据类型…变量名</p><p>2.作用：可传入0-n个参数     当成数组再调出来</p><p>3.可变形参与本类中方法名相同形参不同的方法构成函数重载</p><p>4.可变形参与本类中方法名相同，形参类型也相同的数组不构成函数重载会报错，因为版本遗留以前可变形参是使用数组来实现的。</p><p>5.可变形参必须声明在末尾</p><p><strong>值传递</strong></p><p>变量赋值：</p><p>如果变量是基本数据类型，则赋值时变量所保存的数据值</p><p>如果变量时引用数据类型，则赋值时变量所保存的数据的地址值</p><p>函数参数传递：值传递</p><p>如果变量是基本数据类型，则赋值是变量所保存的数据值</p><p>说如果变量是引用数据类型，赋值时变量所保存的数据的地址值</p><p><strong>注意返回值数组的时候也有同样的问题，如果想不影响对象中的成员，就需要重新new一次</strong></p><h3 id="三大特征-封装-继承-多态"><a href="#三大特征-封装-继承-多态" class="headerlink" title="三大特征 封装 继承 多态"></a>三大特征 封装 继承 多态</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h4><ul><li>高内聚：类内部数据操作细节自己完成，不允许外部干涉</li><li>低耦合“仅对外暴露少量的方法用于使用</li></ul><p>权限修饰符：</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/E:/bolg\source\_posts\JAVA学习\JAVA基础\12" alt="1562645128610"></p><p>private,缺省，public,protected 修饰：属性，方法，构造器，内部类</p><p>缺省，Public:修饰类</p><p><strong>构造器</strong></p><p>格式：权限修饰符 类名（形参列表）{}</p><p>作用：<strong>创建对象+对象初始化</strong></p><p>注意事项：多个构造器彼此构成重载，一旦显示定义构造器就不再提高默认的空参构造器</p><p>属性赋值的先后顺序：</p><p>默认初始化-&gt;显式初始化-&gt;构造器赋值-&gt;对象.方法</p><p><strong>JavaBean</strong></p><ul><li>类是公共的</li><li>有一个无参的公共构造器</li><li>有属性和对应的get/set方法</li></ul><p><strong>this指针</strong></p><p>定义：在类的方法中，使用this.属性或this.方法，调用当前对象属性或方法</p><p>（如果非重名是可以省略this）</p><p>1.可以通过this(形参列表)调用非本方法外的其他构造器</p><p>2.<strong>this构造器必须要声明在首行，只能调一次</strong></p><p>3.n个构造器，最多又n-1个this</p><p><strong>import</strong></p><p>如果同名的类，那么只能在使用的时候使用</p><p>包名.类名 的结构</p><h3 id="这里开始重新整理"><a href="#这里开始重新整理" class="headerlink" title="这里开始重新整理"></a>这里开始重新整理</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h4><p>格式：class A extends B{}</p><p>A:子类，派生类，subclass</p><p>B:父类，超类，基类，superclass</p><p>1.减少代码冗余，提高代码的复用性</p><p>2.便于功能的拓展</p><p>3.为了之后多态性的使用，提供了前提</p><p>体现：一旦子类A继承父类B后，字类A就获取了父类B中的声明</p><p>​        特别的，父类中声明为private的属性或方法，子类继承父类后，仍然认为获取了父类中的私有结构，只是因为封装性的影响，字类无法直接调用</p><p>注意事项</p><ul><li>一个子类不能有多个父类</li><li>一个父类可以有多个子类</li></ul><p>继承后的方法重写</p><p>1.子类重写的方法名和形参列表与父类重写的方法名和形参列表一致</p><p>2.子类的权限修饰应不小于父类被重写方法</p><p>》特殊情况，子类不能重写父类的private方法</p><p>3.返回值：</p><ul><li>父类是void,子类只能是void</li><li>父类是A类型，子类只能是A或A的子类</li><li>父类是基本数据类型，子类只能是相同的基本数据类型</li></ul><p>4.子类方法抛出的异常不大于父类抛出的异常<br>注意区分方法的重载和重写</p><ol><li>static 无法重写，所以如果想要重写就声明为非static</li></ol><p><strong>super</strong></p><p>用来调用父类的属性和方法，与this的意义一致</p><p>对于子类没有重写函数，this和super的功能一样</p><p>在类的构造器首行，针对this()和super（）只能二选一</p><p>默认会调用父类空参super()</p><p>在类的多个构造器中，至少有一个类构造器使用了super(形参列表)，调用父类的构造器</p><p>正是因为调用了父类的构造器，所以子类对象实例化后可以用父类的成员和属性。</p><h4 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h4><p>定义：父类引用指向子类对象，当父类引用调用同名方法执行时子类重写的方法—虚拟方法调用。</p><p>编译期：看的是父类的的声明方法，运行期：执行时是子类重写的方法</p><p>从内存角度来说，内存中实际上时加载了子类的特有属性和方法，但是由于变量声明为父类类型，导致编译时只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用。</p><p>属性都看左边，方法编译看左边，运行看右边</p><p><strong>只适用于方法，不适用于属性</strong>（它还是父类属性）</p><p>虚拟方法：</p><p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给他的不同子类对象，动态调用术语子类的该方法。这样的方法调用在编译器是无法确定的。</p><p>为什么要用多态：</p><p><strong>对于外部可以隐藏具体的子类，而以封装为统一父类</strong></p><p><strong>多个子类的操作可以合成一个父类的调用操作</strong></p><p>编译时行为：未执行前就可以确定</p><p>运行时行为：执行才可以确定(多态性属于运行时方法)</p><p>重载和重写的区别：(面试题)</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/E:/bolg\source\_posts\JAVA学习\JAVA基础\13" alt="1563184207687"></p><p>注意：</p><p>1.子类可以获取父类的private权限的属性或方法，只是不能调用而已</p><p>2.n个构造器，最多n-1个this构造，剩下1个调父类</p><p><strong>instance of</strong></p><p>a instanceof A返回true,则a instanceof B 也返回true，其中类B是类A的父类</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">向下转型（不相关的无法向下转型）：</span><br><span class="line"><span class="keyword">new</span><span class="type"></span>的一定是子类对象，没有子父类就不能强转</span><br><span class="line">Preson m1 = <span class="keyword">new</span> <span class="type">Man</span>（）</span><br><span class="line">Man m2 = (Man)p2  <span class="meta"># 可以使用子类</span></span><br><span class="line">向下转型作用：在函数的时候可以接收参数Object，然后再函数内部再转</span><br></pre></td></tr></table></figure><p><img src="/2019/06/12/JAVA学习/JAVA基础/E:/bolg\source\_posts\JAVA学习\JAVA基础\14" alt="1563187194962"></p><p>Obejct类的使用</p><p>Object是所有类的父类</p><p>属性和方法具有通用性</p><p>属性：无</p><p>方法：</p><p>1.equals()</p><p>2.toString（）</p><p>4.getClass()反射</p><p>5.hashCode()</p><p>6.clone()返回一个对象的复制</p><p>7.finalize() 垃圾收集器调的垃圾回收之前会调用的方法。自己不要调用</p><p>8.wai（），notify() 多线程</p><p>面试题</p><p>== 与equals的区别</p><p>== 运算符</p><p>1.可以使用在基本数据类型和引用数据类型变量中</p><p>2.</p><ul><li><p>比较基本数据类，比较的是两个变量保存到额数据是否相同(不一定类型相同)</p></li><li><p>比较引用数据类，比较的是两个对象的地址值是否相同</p><p>（引用数据类型用==的时候要多注意），尤其是String</p></li></ul><p>equals 方法</p><p>return (this == object)</p><p>1.只适用于引用数据类型</p><p>2.Object类中的定义与==是一样</p><p>3.像String,Date,File,包装类都重写了equals()方法，比较的不是地址而是对象内的内容一致</p><p>4.所以一般需要重写自己定义类的equals方法,alt+shit+s会自动生成重写</p><p>ToString方法</p><p>return getClass().getName()+”@”+Integer.toHexString(hashCode())</p><p>1.像String，Date,File,包装类都重写了toString方法，使得再调用对象的toString方法时返回实体内容。</p><p>2.所以一般需要重写自己定义类的equals方法,alt+shit+s会自动生成重写</p><p><strong>包装类</strong></p><p>针对八种基本数据类型定义的相应的引用类型—包装类,为了赋予基本数据类型类的定义</p><p>意义：</p><ul><li>有可能需要Object放入</li><li>有可能需要基本数据类型的排序之类的。</li></ul><p><img src="/2019/06/12/JAVA学习/JAVA基础/E:/bolg\source\_posts\JAVA学习\JAVA基础\15" alt="1563276563285"></p><p><strong>如果是包装类后默认初始值就全是null了！！！</strong></p><p>以后可以统一适用包装类即可</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/E:/bolg\source\_posts\JAVA学习\JAVA基础\16" alt="1563278499317"></p><p>新特性：自动装箱与拆箱</p><p>自动装箱：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int <span class="selector-tag">a</span> = <span class="number">10</span></span><br><span class="line">Integer <span class="selector-tag">b</span> = <span class="selector-tag">a</span> <span class="comment">//自动装箱，不用再new</span></span><br></pre></td></tr></table></figure><p>自动拆箱</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int <span class="selector-tag">a</span> = <span class="number">10</span></span><br><span class="line">Integer <span class="selector-tag">b</span> = <span class="selector-tag">a</span> <span class="comment">//自动装箱，不用再new </span></span><br><span class="line">int c = b<span class="comment">//自动拆箱，不用再xxxparse</span></span><br></pre></td></tr></table></figure><p>剩下与string类的都需要单独去记</p><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><p>希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间内只有一份</p><p>使用：</p><p>1.修饰属性，方法，代码块，内部类</p><p>修饰属性：</p><p>​    非静态属性：    </p><ul><li>又称实例变量，每个对象都有自身的实例变量;</li><li>随着对象的创建而加载</li></ul><p>​    静态属性：</p><ul><li>又称类变量，多个对象共享同一个静态变量，当修改静态变量后会影响其他所有对象</li><li>随着类的加载而加载，早于对象的创建，类只会加载一次，静态变量在内存中也只会存在一份</li></ul><p>如果子父类共有的<strong>static</strong>方法是不会重写</p><p>内存解析</p><p>静态变量是放在方法区内</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/E:/bolg\source\_posts\JAVA学习\JAVA基础\17" alt="1563366630087"></p><p>如何确定static：</p><p>属性的值是不会随着对象不同而不同</p><p>工具类一般声明为static</p><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>类中直接</p><p>{}</p><p>1.代码块的作用，用来初始化类，对象</p><p>2.代码块如果有修饰的话，只能使用static</p><p>静态代码块：</p><ul><li>随着类的加载而执行,只会执行一次（类加载只有一次）</li></ul><p>非对象代码块：</p><ul><li>随着对象的创建而执行，多个对象执行多次</li><li>用于初始化属性</li></ul><p>3.多个代码块，按顺序执行（不需要写多个代码块）</p><p><strong>static是随着类加载而加载，所以只能调static相关的</strong></p><p>价值：省得写一个静态方法去调用，它直接在加载类或对象得时候自动执行</p><p><strong>类加载不是程序开始加载，而是第一次调用的时候加载，加载完就创建对象</strong></p><p>静态代码块&gt;非静态代码块&gt;构造器   由父到子，静态先行</p><p>属性赋值的先后顺序</p><p>1.默认初始化</p><p>2.显示初始化</p><p>3.在代码块中赋值</p><p>4.构造器中初始化</p><p>5.对象.属性赋值</p><p>1-2-3-4-5</p><p>MVC设计模式</p><p>模型层:model 主要处理数据</p><p>控制层:controller处理业务逻辑</p><p>视图层：view显示数据</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final 可以声明类，方法，变量</p><p>类:此类不能被其他类所继承</p><p>方法：不能被重写</p><p>变量：称为是一个常量        变量包括(属性成员，<strong>对象</strong>，基本数据类型)</p><p>对于不可变变量：不能被重新赋值</p><p>对于可变变量：不能被重新赋值</p><p>也可以是static final 用来修饰属性，全局常量</p><p>static 属性特别之处：</p><p>随着类的加载而加载；早于对象的创建；只要权限允许，就可以通过对象.属性调用</p><p>finnal可以修饰哪些结构，分别表示什么意思</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>当父类没有具体的实例，这样的类叫做抽象类，就是为了用多态，所以是可以使用</p><p>父类 =new 子类</p><p>abstract — 可以用来修饰类，方法</p><p>抽象类特点：</p><p>1.此类不能实例化</p><p>2.抽象类中也有构造器，便于子类实例化时调用</p><p>抽象方法特点：</p><p>public abstract void eat();</p><p>1.包含抽象方法的类一定是抽象类。（否则它就能被调了）</p><p>2.所有的抽象方法（非抽象子类就必须要重写）</p><p>什么时候用？</p><p>1.规定了方法必须重写</p><p>2.多态的时候</p><p>注意点</p><p>1.不能修饰属性，构造器</p><p>2.不能修饰私有方法，静态方法，finnal方法，final类（都是因为子类无法重写父类）</p><h4 id="单例设计模式需要手写，要求非常高"><a href="#单例设计模式需要手写，要求非常高" class="headerlink" title="单例设计模式需要手写，要求非常高"></a>单例设计模式需要手写，要求非常高</h4><h4 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h4><p>解决的问题：</p><ul><li>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现</li><li>在软件开发实现一个算法时，整体不走很固定，这些步骤已经在父类中写好，易变的部分在子类书写。</li></ul><p>实际上与多态一致的，只是这时候父类提供的不是父类而是父类的一个方法来形成一个模板被继承。</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/E:/bolg\source\_posts\JAVA学习\JAVA基础\18" alt="1563601705293"></p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要，则必须能…”的思想。继承是一个“是不是”的关系，而接口则是“能不能”的关系。</p><p>1.只能定义全局常量和抽象方法</p><p>全局常量：public static final 但是书写时可以省略不写(<strong>陷阱</strong>),实现类直接就可以有这个常量</p><p>抽象方法：public abstract 也可以省略不写，实现类需要重写方法</p><p>2.无法实例化，只能由类进行implents</p><p>3.接口可以extends 多个接口</p><p>3.如果类实现覆盖了接口中的所有抽象方法，则此实现类就可以实例化</p><p>如果类没有覆盖接口中的所有抽象方法，则此实现类仍为抽象类</p><p>JAVA实现多个接口，来解决单继承的不足</p><p>多态性的使用接口，就相当于定义了规范，像USB的传输接口，然后每个设备实现这个接口，电脑可以直接调USB的多态方法来统一使用，也就表现了接口的能与不能的关系，面向接口编程。</p><p>抽象类与接口由哪些异同？</p><p>相同点：不能实例化，都可以被继承</p><p>不同点：抽象类有构造器，接口不能声明构造器。。。</p><p>JSD7和JDK8以后这个点可以介绍，随着JDK的迭代让接口往类去迭代</p><p>代理模式：</p><p>代理模式的应用</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/E:/bolg\source\_posts\JAVA学习\JAVA基础\19" alt="1563607298946"></p><p>工厂设计模式</p><p>工厂模式：实现了<strong>创建者与调用者的分离</strong>，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><p>这个在设计模式中继续深入</p><p><strong>JAVA8接口新特性</strong></p><p>JDK8后，接口中可以定义静态方法与默认方法。</p><p>1.接口中定义的静态方法，只能通过接口调用，没法用类来调。</p><p>public static void method1()</p><p>2.通过实现类的对象，可以调用接口中的默认方法。（让接口越来越像类）</p><p>public default void method2(){}</p><p>默认方法可以重写</p><p>在子类没有重写方法的情况下，父类与接口有同名同参数的方法时，默认调用父类—类优先原则</p><p>在子类没有重写方法的情况下，多个接口有同名同参数的方法时，报错—接口冲突<strong>（解决办法重写方法，或者利用类优先原则父类重写）</strong></p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常事件分为两类：</p><p>Error：Java虚拟机无法解决的严重问题，如StackOverflow,OOM一般不编写针对性代码进行处理。</p><p>Exception:其他因编程错误或偶然外在因素导致的一般性问题。</p><p>空指针访问</p><p>读取不存在文件</p><p>网络连接中断</p><p>数组越界</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/E:/bolg\source\_posts\JAVA学习\JAVA基础\20" alt="1563791733863"></p><p>编译：编译部分，是把源文件(代码)转换成机器可以识别的二进制语言，这个过程是针对每一个源文件的（IDE会报红线）。</p><p>运行：把编译出来的可执行文件，在系统中运行的过程，称为程序的运行。</p><p>异常处理：抓抛模型</p><p>过程一：”抛“ 程序在正常执行的过程，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出，其后代码不再执行</p><p>过程二：”抓“ 异常的处理方式 try-catch-finally throws</p><p>try{可能出现异常的代码}</p><p>catch(异常类型 变量名)}{处理异常1}</p><p>catch(异常类型 变量名){处理异常2}</p><p>finally{一定会执行的代码}</p><p>要求：</p><p>1.catch 中的异常类型如果没有子父类关系，则无顺序要求，如果满足子父类关系，则要求子类要在父类上面，否则报错。</p><p>2.try块中声明的变量，在离开try块后不能再被调用</p><p>3.ctrl+t查看继承树顺序就有用了</p><p>4.使用try-catch使得编译时不再报错，相当于我们将一个编译时异常延长到了运行时异常</p><p>常用的两种方法</p><p>1.syso(e.getMessage());</p><p>2.e.printStackTrace();</p><p>finally使用：</p><p>1.无论如何都会执行，即使try/catch顺利执行并return ,return前也会执行</p><p>2.资源回收和释放（连接的close，或者释放）</p><p>throws + 异常类型</p><p>1.写在方法的声明处，指明此方法执行时可能会抛出的异常类型，当出现异常，会在异常代码生成一个异常类对象，此对象若满足throws异常类型，则后续代码不再执行。</p><p>2.子类重写方法抛出的异常必须小于等于父类抛出的异常。（如果父类没有抛异常，那子类也不能抛了）因为多态的时候，编译时看的是左边即父类</p><p>手动抛出异常对象</p><p>throw new RuntimeException(“自定义报错信息”)</p><p>运行时异常不需要try-catch解决，只有编译时异常需要</p><p>用户自定义异常类</p><p>1.继承于现有的异常结构，要么是runtimeException（不需要处理）,要么是Exception（需要try-catch）</p><p>体会：</p><p>1.开发中，由于运行时异常比较常见，我们通常不针对运行时异常编写try-catch-finally/throws，针对编译时异常，我们一定要考虑异常的处理。</p><p>2.如何使用throws or try-catch-finnally</p><p>​    2.1 当父类没有throws，子类想重写方法只能用try</p><p>​    2.2 执行的方法a中，调用几个方法，建议这几个方法使用throw方式，再执行a的方法使用try</p><p>3.异常是为了给用户更好的行为，而不是为了程序员的代码</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/E:/bolg\source\_posts\JAVA学习\JAVA基础\21" alt="1563865376564"></p><p>throws：异常处理的方式，抓（下游治污）</p><p>throw：生成异常对象，抛（上游排污）</p><p>4.<strong>异常尽量抛出不要捕获，没有出错的情况下没人会看日志，空指针你觉得它不会空就不要给它做检查，这样才能尽早暴露程序的缺陷</strong>，解决问题时重新考虑新情况下如何去做，而不是通过捕获异常或者检查来掩盖问题；异常是需求所需要定义的，不是给程序员来解决问题的。</p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>进程</p><ul><li><p>是程序的一次执行过程，是一个动态的过程，有它自身的产生，存在和消亡的过程。</p></li><li><p>进程是资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</p></li></ul><p>线程</p><ul><li>是一个程序内部的执行路径</li><li>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小</li><li>一个进程中的多个线程共享相同的内存地址空间，它们从同一堆中分配对象，可以访问相同的变量和对象，这使得线程间更简便，高效，但多个线程操作共享系统资源可能会带来安全隐患。</li></ul><p>进程是资源分配的最小单位，线程是CPU调度的最小单位</p><p>进程时多个程序的运行，一般都是在单个程序中分配任务所以是多线程。</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/E:/bolg\source\_posts\JAVA学习\JAVA基础\23" alt="1563951620716"></p><p>虚拟机栈，本地方法栈，程序计数器，一个线程一个</p><p>方法区，堆，一个进程一个，多个线程共享</p><p><strong>单核CPU和多核CPU</strong></p><p>单核CPU是一种假的多线程，采用轮换由于CPU时间单元短，因此感觉不出来。</p><p><strong>并发与并行</strong></p><p>并发：多个CPU同时执行多个任务</p><p>并行：一个CPU(采用时间片)同时执行多个任务（资源争夺）</p><p>多线程的优点：</p><p>1.提高应用程序的响应</p><p>2.提高计算机系统CPU的利用率</p><p>3.改善程序结构，将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</p><p>何时需要多线程：</p><p>1.程序同时执行两个或多个任务</p><p>2.程序需要实现一些等待的任务</p><p>3.需要一些后台运行的程序时</p><p>多线程的创建：</p><p>方式一：继承于Thread类</p><p>1.创建一个继承于Thread类的子类</p><p>2.重写Thread类的run()—&gt;此线程执行的操作声明在run()中</p><p>3.创建Thread类的子类对象</p><p>4.通过此对象调用start()</p><p>注意点：</p><p>1.不能直接调用run（）启动线程</p><p>2.线程无法同时start()多次，想创建多个线程就创建多个线程对象</p><p>常用方法：</p><p>start():启动线程</p><p>run():线程被调度时执行的操作</p><p>getName():返回线程的名称</p><p>setName():设置该线程名称</p><p>currentThread():返回当前线程。在Thread子类中就是this，所以通常用于主线程和                       Runnable实现类</p><p>yield():释放当前cpu的执行权，但是有可能又抢回来</p><p>join():线程a调用线程b的join(),线程a进入阻塞状态，知道线程b完全执行完，线程a才继续走</p><p>sleep(millitime)：使当前线程进入休眠阻塞</p><p>isalive():判断当前线程是否存活</p><p>线程优先级</p><p>Java的调度方法：</p><ul><li>同优先级线程组成先进先出队列，使用时间片策略</li><li>对高优先级，使用优先调度的抢占式策略</li></ul><p>MAX_PRIORITY:10</p><p>MIN_PRIORITY:1</p><p>NORM_PRIORITY:5(默认)</p><p>getPriority():返回线程有限制</p><p>setPriority(int newPriority):改变线程优先级</p><p>说明：线程创建时继承父线程的优先级</p><p>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用（如果你想有完全优先级，那就没必要用线程）</p><p>方式二：实现Runnable方法</p><p>1.创建一个实现了Runnable接口的类</p><p>2.实现类取实现Runable中的抽象方法，run()</p><p>3.创建实现类的对象</p><p>4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</p><p>5.通过Thread类的对象调用start()</p><p>这种方法只能用Thread.currentThread()去调用当前线程了</p><p><strong>两种方式的区别：</strong></p><p>开发中，优先选择实现Runable接口方式</p><p>1.实现的方式没有类的单继承性的局限性</p><p>2.实现的方式更适合处理多个线程共享数据的情况</p><p>3.理解上线程就应该是一种方法或特性，属于接口，而不是父子的关系</p><p>线程生命周期</p><p>Thread.State类定义了线程的状态</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/24" alt="1564112278574"></p><p><img src="/2019/06/12/JAVA学习/JAVA基础/25" alt="1564113152915"></p><p>线程安全问题</p><ul><li>多个线程执行的不确定性引起结果的不稳定性</li><li>多个线程对数据的共享，会造成操作的不完整性，会破坏数据</li></ul><p>因为你无法保证同一数据各个线程的操作时刻，因此在边界值会出错。</p><p>如何解决：</p><p>​    当一个线程a在操作ticket的时候，其他线程不能参与进来，直到线程a操作完了才可以开始ticket，这种情况即使线程a出现了阻塞也不能改变。</p><p>方法一：同步代码块</p><p>synchronized(同步监视器){</p><p>//需要被同步的代码</p><p>}</p><p>说明：1.操作共享数据的代码，即为需要被同步的代码，哪怕不是赋值操作，涉及到共享数据都需要同步，如同步。</p><p>2.共享数据：多个线程共同操作的变量</p><p>3.同步监视器，俗称锁，任何一个类的对象都可以充当锁。要求，<strong>多个线程必须共用同一把锁</strong>，只要保证唯一就可以了。</p><p>4.runnable的时候用this，implement的时候用xx.class</p><p>方法二：同步方法</p><p>​    如果操作共享数据的代码完整的声明在一个方法中</p><p>Runable方式：直接声明private synchronized void 方法名(){同步代码}，锁是this</p><p>Thread方式：直接声明private static synchronized void 方法名(){同步代码}，锁是class</p><p>同步的方式，解决了线程的安全问题—好处</p><p>操作同步代码的时候，相当于是单线程执行，降低了效率—局限性</p><p>单例模式懒汉式可能会出现线程安全问题，需要用同步去解决。</p><p>死锁</p><p>不能的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程死锁。（某个线程被sleep了，就会被别的线程占用死锁）</p><p>死锁—尽量不要嵌套同步，而且同步也不要写那么多</p><p>方式三 Lock锁</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentranLock()</span><br><span class="line">然后在同步代码代码之前调用<span class="keyword">lock</span>.<span class="keyword">lock</span>()</span><br><span class="line">再要跳出同步代码块的时候调用<span class="keyword">lock</span>.unlock()</span><br></pre></td></tr></table></figure><p>面试题：</p><p>synchronized与Lock的异同？</p><p>相同：二者都可以解决线程安全问题</p><p>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器，Lock需要手动启动，也需要手动结束。</p><p>如何解决线程安全问题？有几种方式</p><p>sleep()和wait()的异同？</p><p>1.相同点：一旦执行方法，都可以使得当前线程进入阻塞状态。</p><p>2.不同点：</p><p>1）两个方法声明的位置不同，Thread类中声明sleep(),Object类中声明wait()</p><p>2) 调用的范围不同：sleep()可以在任何场景下调用，wait()必须在同步代码块下调用</p><p>3）在同步代码块中：sleep()不会释放锁，wait()会释放锁。</p><p>线程的通信</p><p>wait()使当前线程进入阻塞状态，并释放同步监视器</p><p>notify()一旦执行此方法，就会唤醒被wait的一个线程</p><p>Notifyall()一旦执行此方法，就会唤醒所有被wait的线程</p><p>注意</p><ul><li>以上方法只能在同步代码块or同步方法中，使用lock方法是其他方式进行通信。</li><li>这三个方法的同步监视器要求一致，否则会报异常</li><li>这三个方法是定义在java.object中，而不是Thread</li><li>notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还 在别人手里，别人还没释放。如果notify/notifyAll方法后面的代码还有很多，需要这些代码执行完后才会释放锁</li></ul><p>JDK5.0新增线程创建方式(都优于上面的)</p><p>实现Callable接口</p><p>1.创建实现Callable的实现类</p><p>2.实现call方法，将此线程需要执行的操作声明在call（）中</p><p>3.创建类的对象</p><p>4.将此Callable接口实现类对象传递到FutureTask构造器中，创建FutureTask对象</p><p>5.将FutureTask对象作为参数传递到Thread类的构造器中</p><p>6.获取Callable中call方法的返回值(可选)</p><p>优点：</p><p>1.call方法有返回值</p><p>2.可以抛出异常</p><p>新增线程池</p><p>提前创建号多个线程，放入线程池中，使用时直接获取，使用完放回池中，避免频繁创建销毁，实现重复利用。</p><p>优点：</p><p>1.提高响应速度（减少创建新线程的时间）</p><p>2.降低资源消耗</p><p>3.便于线程管理</p><p>corePoolSize 核心池的大小</p><p>maximumPoolSize 最大线程数</p><p>keepAliveTime 线程没有任务时最多保持多长时间会终止</p><p>Executors:线程池的工厂类</p><p>.newCachedThreadPool():创建一个可根据需要创建新线程的线程池</p><p>.newFixedThreadPool(n):创建一个可重用固定线程数的线程池</p><p>.newSingleThreadExecutor():创建一个只有一个线程的线程池</p><p>.newScheduledThreadPool(n)：创建一个线程池，他可安排在给定延迟后运行命令或定期的执行</p><p>1.提供指定线程数量的线程池</p><p>ExecutorService service（这是一个接口） = Executors.newFixedThreadPool(10)</p><p>2.设置属性</p><p>由于service是接口，所以设置需要强转为Thread然后再使用.set属性</p><p>2.执行指定的线程的操作，需要提供实现Runnable接口或callable接口实现类的对象</p><p>service.execute(new 你的实现类)</p><p>service.execute(new 你的实现类)</p><p>3.关闭连接池</p><p>service.shutdown()</p><p>自我体会：</p><p>要有一个同步监视器，如果有同步的数据的话需要新建一个同步的类里面放同步方法，然后各个线程去调用这个类的同步方法，而不是在线程内部建。</p><p>为什么用多进程而不是多线程 </p><p>1.从并行的角度来说，两者并无太大区别，进程可能需要一些创建代价</p><p>2.主要区别还是在线程具有共享资源，而进程具有隔离的特性。</p><h2 id="从这里开始整理"><a href="#从这里开始整理" class="headerlink" title="从这里开始整理"></a>从这里开始整理</h2><p><img src="/2019/06/12/JAVA学习/JAVA基础/26" alt="1564748655665"></p><p>yield，释放CPU占据权，不会释放锁，但是可以给其他没有锁的线程抢</p><h3 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h3><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><p>1.是一个final类，代表不可被继承</p><p>其中字符存在final的char型数组中代表不可变的字符序列，即它们的值在创建后不能更改</p><p>2.实现了Serializable接口：表示字符串是支持序列化的</p><p>   实现了Comparable接口：表示字符串是可以比较大小的</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/27" alt="1566131789488"></p><ul><li><p>通过字面量赋值的字符串是创建于方法区中</p></li><li><p>方法区是不会存在两个相同的值</p></li><li>所有在方法区内的操作都是重新指定内存区域赋值（包括重新赋值，replace），性能差</li></ul><p>（为什么final又可以重新赋值，因为虽然对象里面是一个final数组不能赋值，但是整个对象仍然是可以赋值的，final类只是不能继承）</p><p><strong>理解不可变性和常量池</strong></p><p><img src="/2019/06/12/JAVA学习/JAVA基础/28" alt="1566134033123"></p><p>常量池内的数据是不可变性，对于new String的方法得到对象，其变量成员finalchar数组存的就是常量池内的地址</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/29" alt="1566134301511"></p><p>面试题：</p><p>String s = new String(‘abc’)在内存中创建了几个对象</p><p>两个，一个是堆空间中new的，另一个是char[]对应的常量池中的数据“abc”</p><p>String 的实例化方式</p><p>方式一：通过字面量定义的方式（方法区）</p><p>方式二：通过new+构造器的方式（常量池）</p><p>String的不同拼接操作</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/30" alt="1566185805128"></p><p>非常重要的两个结论</p><p>如果你把变量声明为final了之后，它就变成final，变成常量之后拼接就还常量</p><p>面试题</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/31" alt="1566186594684"></p><p>传递的是地址，然后由于不可变性直接把地址重新赋值。参数的传递并不是把原来的变量丢过来，是通过新建变量，然后值传递或者地址传递过来的。</p><p>内存结构：</p><p>堆和方法区，常量池是方法区的一部分。</p><p>String常用方法</p><p>返回String,都是新的对象不影响原来传入的</p><p>int length():返回字符串的长度：return value.length</p><p>boolean isEmpty():判断是否是空字符串 return value.length == 0</p><p>char charAt(int index):返回某索引处的字符 return value[index]</p><p>String toLowerCase():将所有字符转换为小写</p><p>Sttring toUpperCase():将所有字符转换为大写</p><p>String trim():去除字符串的首尾空格，中间空格不会被消除</p><p>boolean equals(Object obj):比较字符串的内容</p><p>String concat(String str):将指定字符串连接到此字符串的结尾，等价于“+”</p><p>int compareTo(String another):比较两个字符串的大小，按asca码进行排序</p><p>String substring(int beginIndex):取子串</p><p>String substring(int beginIndex,int endIndex)[begin,end)</p><hr><p>boolean endsWith(String suffix):测试此字符串是否以指定的后缀结束</p><p>boolean startsWith(String prefix):测试此字符串是否以指定的前缀开始</p><p>boolean startswith(String prefix,int toffset):测试此字符串从指定索引开始的子字符串是否以指定前缀开始</p><p>boolean contain(charSequence s):测试此字符串是否包含子串</p><p>int indexOf(String str):返回子串首次出现的首位置，无返回-1</p><p>int indexOf(String str,int fromIndex):从索引位置开始往后返回字串首次出现的首位置</p><p>String replace(char oldChar,char newChar):返回一个新字符串，它是用newChar替换oldChar（全替换）</p><p>String replace(String target,String repalcement):返回一个新字符串，它是用newChar替换oldChar（全替换）</p><p>String replaceAll(String regex,String replacement):使用正则替换</p><p>String replaceFirst(String regex,String replacement)</p><p>boolean matches(String regex)判断此字符串是否匹配给定的正则表达式</p><p>String[] split(String regex):根据给定正则表达式的匹配拆分此字符串</p><p>String[] split(String regex,int limit):根据给定正则表达式的匹配拆分此字符串,最多不超过limit次</p><p>String转换</p><p>String与基本数据类型的转换</p><p>Integer.parseInt(str1)</p><p>String.valueOf(num)</p><p>String与char[]数组转换</p><p>str1.toCharArray()</p><p>new String(chr1)</p><p>String与byte[]数组</p><p>str1.getBytes()</p><p>new String(by1)</p><p>编码：字符串—》字节（看得懂—-》看不懂的二进制数据）</p><p>解码：编码的逆过程,字节—》字符串（看不懂的二进制数据—》看得懂）</p><h4 id="StringBuffer-amp-StringBuilder"><a href="#StringBuffer-amp-StringBuilder" class="headerlink" title="StringBuffer &amp;StringBuilder"></a>StringBuffer &amp;StringBuilder</h4><p>String:不可变的字符序列 底层结构：final char型数组</p><p>StringBuffer:可变的字符序列（线程安全，效率低） 底层结构：char型数组</p><p>StringBuilder:可变的字符序列（线程不安全，效率高）底层结构：char型数组</p><p>可变：它可以在原有字符串上进行修改和增加，都不会创建新对象</p><p>StringBuffer源码分析，Builder是一致的</p><p>1.空参创建：创建一个空数据的时候，new char[16]创建了一个长度为16的数组</p><p>2.有参创建：创建一个char数组，new char[参数.length+16]</p><p>3.长度输出：不需要计算16长度，返回的不是char数组的长度</p><p>4.扩容数组：当超过16长度之后，就需要扩容，底层会进行Array.copyOf(value,newCapacity(新容量))，默认情况下，扩容为原有长度*2+1，同时将原有数组中的元素复制到新的数组中</p><p>指导意义，开发中建议使用指定容量，避免它不断进行扩容</p><p>常用方法：</p><p>StringBuffer append(xx):提供了很多的append（）方法，进行字符串拼接</p><p>StringBuffer delete(int start,int end):删除指定位置的内容</p><p>StringBuffer replace(int start,int end,String str):把[start,end)的内容替换str</p><p>StringBuffer insert(int offset,String str):在指定位置插入str</p><p>StringBuffer reverse():反转</p><p>int indexOf(String str)</p><p>String substring(int start,int end)</p><p>int length()</p><p>char charAt(int n)   for循环</p><p>void setCharAt(int n,char ch)</p><p>对比String，StringBuffer,StringBuilder效率</p><h4 id="获取时间戳"><a href="#获取时间戳" class="headerlink" title="获取时间戳"></a>获取时间戳</h4><p>System.currentTimeMillis() 获得毫秒数</p><p>构造器1：util.Date</p><p>Date date = new Date()</p><p>date.toString():显示当前的年，月，日，时，分秒</p><p>getTime():获取当前Date对象对应的毫秒数</p><p>构造器2：util.Date</p><p>Date date1 = new Date(long:毫秒数) 创建指定毫秒数的date</p><p>sql.Date（extends util.Date） 这是表示数据库内的Date数据类型</p><h3 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h3><p>1.写算法的时候，注意参考这个项目，注释分不走写，第一点做什么，第二点做什么。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>以下的区别</p><p><img src="/2019/06/12/JAVA学习/JAVA基础/E:/bolg\source\_posts\JAVA学习\JAVA基础\22" alt="1563865722134"></p><p>final,finally,finalize的区别</p><p>创建多线程有几种方式？四种</p><p>有什么想问的？</p><p>问过来做什么项目，技术是什么，别问薪资</p><p>问题？</p><p>1.先描述问题</p><p>2.然后在分点答</p><p>3.描述开发中的情景</p><h1 id="java一百个坑"><a href="#java一百个坑" class="headerlink" title="java一百个坑"></a>java一百个坑</h1><p>1.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int <span class="selector-tag">i</span> = <span class="number">10</span></span><br><span class="line">int j = <span class="number">20</span></span><br><span class="line">system<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="selector-tag">i</span> =j)</span><br></pre></td></tr></table></figure><p>20</p><p>2.控制台获得变量输出</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">Scanner <span class="built_in">scan</span> = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">String info = <span class="built_in">scan</span>.next();</span><br><span class="line"><span class="built_in">int</span> id = <span class="built_in">scan</span>.nextInt();</span><br></pre></td></tr></table></figure><p>3.</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">sum</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">sum</span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">sum</span> = <span class="number">1</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">sysout(<span class="keyword">sum</span>)</span><br></pre></td></tr></table></figure><p>出错，因为在编译的过程，程序有可能认为不会进入for循环。</p><p>把for循环去掉之后可以正常编译</p><p>4.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] <span class="selector-tag">a</span> =new int[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">char[] <span class="selector-tag">b</span> = new char[]&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;</span><br><span class="line"><span class="function"><span class="title">syso</span><span class="params">(a)</span></span></span><br><span class="line"><span class="function"><span class="title">syso</span><span class="params">(b)</span></span></span><br></pre></td></tr></table></figure><p>地址值</p><p>abc</p><p>因为syso重载了char数组</p><p>5.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int <span class="selector-tag">i</span> = <span class="number">10</span></span><br><span class="line">char <span class="selector-tag">a</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="title">syso</span><span class="params">(i==a)</span></span><span class="comment">//true</span></span><br><span class="line">char <span class="selector-tag">b</span> = <span class="string">'a'</span></span><br><span class="line"><span class="function"><span class="title">syso</span><span class="params">(a==b)</span></span><span class="comment">//true</span></span><br><span class="line"><span class="function"><span class="title">syso</span><span class="params">(i==b)</span></span><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>6.</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> o1 = <span class="literal">true</span> ? <span class="keyword">new</span> <span class="built_in">Integer</span>(<span class="number">1</span>):<span class="keyword">new</span> <span class="built_in">Double</span>(<span class="number">2.0</span>)</span><br><span class="line">syso(o1)</span><br></pre></td></tr></table></figure><p>1.0  </p><p>三元运算符要求两边类型要一致</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Integer</span> i = <span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">1</span>)</span><br><span class="line">Interger j = <span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">1</span>)</span><br><span class="line">syso(i==j)</span><br><span class="line"><span class="built_in">Integer</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Integer</span> n = <span class="number">1</span>;</span><br><span class="line">syso(m==n)</span><br><span class="line"><span class="built_in">Integer</span> x = <span class="number">128</span>;</span><br><span class="line"><span class="built_in">Integer</span> y =<span class="number">12</span></span><br><span class="line">syso(x == y)</span><br></pre></td></tr></table></figure><p>fasle,true,false</p><p>Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],保存了-128-127范围的整数。如果我们适用自动装箱的方式，给Integer赋值的范围在-128-127范围内，可以直接适用数组中的元素不用再去new，提高效率。</p><p>11.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="type">A</span>&#123;</span><br><span class="line">    int x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    int x =<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="title">implents</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    syso(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承，相同名，是最近原则，去找。</p><p>接口，相同名，会报错，因为接口与继承类是在同一层</p><p>多个接口可以有相同函数名，因为重写一个就可以了。</p><h3 id="eclipse快捷键"><a href="#eclipse快捷键" class="headerlink" title="eclipse快捷键"></a>eclipse快捷键</h3><p>2.快速修复：ctrl +1</p><p>6.删除行：ctrl+d</p><p>9.查看原码：ctrl+鼠标</p><p>12.查看继承树：ctrl +t</p><p>13.反撤销:ctrl + y</p><p>15.查看当前类结构:ctrl+o</p><p>3.批量自动导包：ctrl+shift+o</p><p>10.搜索源码：ctrl+shift+t</p><p>14.整理格式：ctrl+shift    +f</p><p>16.大写互换小写： ctrl+shift+x 大写 ctrl+shift +y</p><p>4.多行注释：ctrl+shif+/</p><p>5.取消多行注释：ctrl+shift+\</p><p>21复制当前行：ctrl+alt+上箭头/下箭头</p><p>1.补全代码功能：alt+/</p><p>7.上下移动代码：alt+up alt+down.</p><p>11.查看原码的时候进入下一个页面和上一个页面：alt+left  和alt+right</p><p>8.切换下一行空白处：shift+回车</p><p>19.光标开头，末尾：home end</p><p>17.自动补构造器和setter/getter：alt+shift+s</p><p>IDEAL</p><p>18.Alt+Enter :修复类似ctrl+1</p><h3 id="Eclipse调试"><a href="#Eclipse调试" class="headerlink" title="Eclipse调试"></a>Eclipse调试</h3><p>step over:一行行代码调试</p><p>step into:跳入方法</p><p>steo return: 跳出方法</p><p> drop into frame :回到当前行所在方法的第一行</p><p>resume:执行到下一个断点处，若没有就结束</p><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><p>IDEA的project是最顶级结构，代表了一个工程</p><ul><li><p>一个窗口只能由一个project即项目</p></li><li><p>多个module构建出一个项目，因为不同module可以由不同的语言构成。</p></li></ul><p>快捷键：</p><p>导入eclipse</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尚硅谷JAVA基础视频说明&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码架构</title>
    <link href="http://kodgv.xyz/2019/05/28/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    <id>http://kodgv.xyz/2019/05/28/代码架构/</id>
    <published>2019-05-28T11:21:49.000Z</published>
    <updated>2019-07-08T11:38:34.670Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>要有debug和release的概念，在时间慢的情况下，先用小数据保证跑通，而不是用搞大数据搞来搞去</li><li>要保证代码的层次，高层次和低层次的分开，不要混杂在一起</li><li>要保证非混淆性</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;要有debug和release的概念，在时间慢的情况下，先用小数据保证跑通，而不是用搞大数据搞来搞去&lt;/li&gt;
&lt;li&gt;要保证代码的层次，高层次和低层次的分开，不要混杂在一起&lt;/li&gt;
&lt;li&gt;要保证非混淆性&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
      <category term="项目管理" scheme="http://kodgv.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="经验" scheme="http://kodgv.xyz/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>代码架构</title>
    <link href="http://kodgv.xyz/2019/05/28/%E5%BC%80%E5%8F%91%E5%9D%91/"/>
    <id>http://kodgv.xyz/2019/05/28/开发坑/</id>
    <published>2019-05-28T11:21:49.000Z</published>
    <updated>2019-07-08T11:39:23.767Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>要有debug和release的概念，在时间慢的情况下，先用小数据保证跑通，而不是用搞大数据搞来搞去</li><li>要保证代码的层次，高层次和低层次的分开，不要混杂在一起</li><li>要保证非混淆性</li></ul><ul><li><p>上升到服务器：一定要注意日志</p></li><li><p>考虑存储的变化和溢出</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;要有debug和release的概念，在时间慢的情况下，先用小数据保证跑通，而不是用搞大数据搞来搞去&lt;/li&gt;
&lt;li&gt;要保证代码的层次，高层次和低层次的分开，不要混杂在一起&lt;/li&gt;
&lt;li&gt;要保证非混淆性&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
      <category term="项目管理" scheme="http://kodgv.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="经验" scheme="http://kodgv.xyz/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>git知识点</title>
    <link href="http://kodgv.xyz/2019/05/26/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/git%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://kodgv.xyz/2019/05/26/项目管理/git知识点/</id>
    <published>2019-05-26T13:44:33.000Z</published>
    <updated>2019-08-18T12:09:26.020Z</updated>
    
    <content type="html"><![CDATA[<p>git 知识点整理</p><a id="more"></a><p>[TOC]<br>整理来源：</p><p><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">git动画学习</a></p><p><a href="https://blinkfox.github.io/2018/09/24/ruan-jian-gong-ju/git/git-zhi-shi-dian-zheng-li/#toc-heading-13" target="_blank" rel="noopener">git 知识点问答</a></p><p><a href="https://www.jianshu.com/p/34cfe097e06a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">git知识点整理</a></p><p>要有分支树的概念，各个分支都是在同一棵树上的</p><h2 id="分支管理最佳实践与团队项目版本管理方案"><a href="#分支管理最佳实践与团队项目版本管理方案" class="headerlink" title="分支管理最佳实践与团队项目版本管理方案"></a>分支管理最佳实践与团队项目版本管理方案</h2><h3 id="单主干"><a href="#单主干" class="headerlink" title="单主干"></a>单主干</h3><ul><li>所有成员都在 master 分支上进行开发</li><li>使用 tag 或发布分支进行发布</li><li>在 master 分支中修复 bug，再 cheery-pick解释 到发布分支</li><li>适用于小项目</li><li>因为在同一分支上进行开发，协作人员之间必须有良好的交流</li><li>省去另开分支的时间，不用频繁切换分支</li></ul><p><img src="/2019/05/26/项目管理/git知识点/6" alt="img"></p><h3 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h3><ul><li>只包含两类分支：master 和修改分支，master 作为部署分支</li><li>无论是 feature，bug 还是 hotfix 都从 master 另开分支</li><li>从分支到 master 的合并需要提交 pull request</li><li>在 pull request 上需要进行代码审查和测试，通过后再合并</li><li>Release 在 master 上通过 tag 进行标记</li><li>对自动化测试、持续集成等相关基础设施要求较高，新分支的测试和部署人工操作较为繁杂</li></ul><p><img src="/2019/05/26/项目管理/git知识点/7" alt="img"></p><h3 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h3><ul><li>同样以 master 作为部署分支，其上所有 commit 都应围绕版本而生</li><li>共有五类分支 master，develop，feature，release 和 hotfix</li><li>Release 分支测试的问题直接在 release 分支上修改，测试完毕后再分别合并到 master 和 develop，相当于 develop 的需求冻结，可以让新功能开发和版本测试同步进行</li><li>合并时多数情况不使用 fast-forward 模式</li><li>Hotfix 分支用于修复线上问题，向 master 和 develop 合并</li><li>Feature，release，hotfix 分支合并完成后应被删除</li><li>操作较为繁琐，有对应的命令行工具</li><li>较为适合于长期大型项目</li></ul><div class="table-container"><table><thead><tr><th>分支类型</th><th>命名规范</th><th>创建自</th><th>合并至</th><th>说明</th></tr></thead><tbody><tr><td>master</td><td>master</td><td>-</td><td>-</td><td>部署版本分支</td></tr><tr><td>develop</td><td>develop</td><td>-</td><td>-</td><td>代码集成分支</td></tr><tr><td>feature</td><td>feature/*</td><td>develop</td><td>develop</td><td>新功能</td></tr><tr><td>release</td><td>release/*</td><td>develop</td><td>develop 和 master</td><td>一次新版本的发布</td></tr><tr><td>hotfix</td><td>hotfix/*</td><td>master</td><td>develop 和 master</td><td>生产环境中发现的紧急 bug 的修复</td></tr></tbody></table></div><p><img src="/2019/05/26/项目管理/git知识点/8" alt="img"></p><h3 id="团队项目版本管理方案"><a href="#团队项目版本管理方案" class="headerlink" title="团队项目版本管理方案"></a>团队项目版本管理方案</h3><blockquote><p><strong>核心问题</strong></p><ul><li>如何进行分支管理，怎样合并</li><li>是否要进行代码审阅、评论</li><li>是否以及如何进行测试和部署</li><li>围绕人为核心还是功能为核心</li></ul></blockquote><h3 id="单人小项目"><a href="#单人小项目" class="headerlink" title="单人小项目"></a>单人小项目</h3><h4 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h4><ul><li>单人完成项目，无需他人审查</li><li>小功能快速迭代，无需额外的 feature 分支</li><li>主要目标为保存代码进度及回退</li><li>需要注意对接交递项目时的问题</li></ul><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><ol><li>单主干</li><li>Master + develop 混合<ul><li>Develop 分支进行开发、修复</li><li>Master 分支进行版本发布、部署</li></ul></li></ol><h3 id="多人协作项目"><a href="#多人协作项目" class="headerlink" title="多人协作项目"></a>多人协作项目</h3><h4 id="关注点-1"><a href="#关注点-1" class="headerlink" title="关注点"></a>关注点</h4><ul><li>需要一定的代码审查</li><li>需要保证沟通的效率</li><li>分支与对应功能绑定</li><li>潜在的代码审核</li></ul><h4 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h4><ol><li>Github Flow</li><li>Git Flow 简化<ul><li>单一 develop 分支</li><li>可选的 hotfix 分支</li></ul></li></ol><h3 id="组内共享项目"><a href="#组内共享项目" class="headerlink" title="组内共享项目"></a>组内共享项目</h3><h4 id="关注点-2"><a href="#关注点-2" class="headerlink" title="关注点"></a>关注点</h4><ul><li>以分享知识和共同进步为核心</li><li>代码以人为本</li><li>需要 merge request，共同评论，学习他人优秀代码以及提出改进意见</li></ul><h4 id="方案-2"><a href="#方案-2" class="headerlink" title="方案"></a>方案</h4><ul><li>Master + develop 主开发分支</li><li>从 develop 分支分出 [username]/dev 个人开发分支</li><li>个人开发分支上可使用任意的模式</li><li>从 [username]/dev 禁止合并到 develop</li><li>需要合并及需要从 develop 分支拉去时从 /dev 分支分出 [username]/merge/[mm-dd] 分支并提交 merge request，冻结个人代码版本</li></ul><h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><p><a href="https://www.yiibai.com/git/git_commit.html" target="_blank" rel="noopener">中文API解释</a></p><h3 id="git-status-查看文件状态"><a href="#git-status-查看文件状态" class="headerlink" title="git status 查看文件状态"></a>git status 查看文件状态</h3><p>使用 <code>git status</code> 时，实际上可以使用更为方便的指令来达到更为紧凑的格式输出。比如使用 <code>git status -s</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"></span><br><span class="line">#  M 靠右的 M 表示修改过的文件并且还未被放入暂存区</span><br><span class="line"> M README</span><br><span class="line"> </span><br><span class="line"># MM 靠左的 M 表示该文件被修改后放入了暂存区，靠右的表示修改过的文件并且还未被放入暂存区，所以 Rakefile 文件被修改过后放入了暂存区，但是之后又进行了修改，还未将最后一次修改放入暂存区</span><br><span class="line">MM Rakefile</span><br><span class="line"></span><br><span class="line"># A 表示新添加到暂存区的文件</span><br><span class="line">A  lib/git.rb</span><br><span class="line"></span><br><span class="line"># M 靠左的 M 表示该文件被修改后放入了暂存区</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line"></span><br><span class="line"># ?? 表示还未被跟踪</span><br><span class="line">?? LICENSE.txt  </span><br><span class="line"></span><br><span class="line"># 所以此时暂存区中的文件有 Rakefile, lib/git.rb, lib/simplegit.rb</span><br></pre></td></tr></table></figure><h3 id="git-diff-查看文件前后对比"><a href="#git-diff-查看文件前后对比" class="headerlink" title="git diff 查看文件前后对比"></a>git diff 查看文件前后对比</h3><p><code>git diff</code> 可以说是 <code>git status</code> 的具体版本，<code>git status</code> 只能查看修改了哪些文件，而 <code>git diff</code> 能够具体到该文件的某一部分。通常有以下两个用法</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">diff </span>&lt;file&gt; <span class="comment"># 比较当前文件和暂存区文件差异 git diff</span></span><br><span class="line">git <span class="keyword">diff </span>&lt;id1&gt;&lt;id1&gt;&lt;id2&gt; <span class="comment"># 比较两次提交之间的差异</span></span><br><span class="line">git <span class="keyword">diff </span>&lt;<span class="keyword">branch1&gt; </span>&lt;<span class="keyword">branch2&gt; </span><span class="comment"># 在两个分支之间比较</span></span><br><span class="line">git <span class="keyword">diff </span>--staged <span class="comment"># 比较暂存区和版本库差异</span></span><br><span class="line">git <span class="keyword">diff </span>--<span class="keyword">cached </span><span class="comment"># 比较暂存区和版本库差异</span></span><br></pre></td></tr></table></figure><h3 id="git-commit-提交记录"><a href="#git-commit-提交记录" class="headerlink" title="git commit  提交记录"></a>git commit  提交记录</h3><p>​    Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add . </span><br><span class="line"><span class="variable">$ </span><span class="comment"># 或者~</span></span><br><span class="line"><span class="variable">$ </span>git add newfile.txt</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"the commit message"</span> <span class="comment">#</span></span><br><span class="line"><span class="variable">$ </span>git commit -a <span class="comment"># 会先把所有已经track的文件的改动`git add`进来，然后提交(有点像svn的一次提交,不用先暂存)。对于没有track的文件,还是需要执行`git add &lt;file&gt;` 命令。</span></span><br><span class="line"><span class="variable">$ </span>git commit --amend <span class="comment"># 增补提交，会使用与当前提交节点相同的父节点进行一次新的提交，旧的提交将会被取消。</span></span><br></pre></td></tr></table></figure><p>​    git commit之前要保证修改文件已执行git add添加进入暂存区。</p><h3 id="git-rm-删除"><a href="#git-rm-删除" class="headerlink" title="git rm 删除"></a>git rm 删除</h3><p>要从 Git 中移除某个文件，就必须从已经跟踪的文件清单中删除，然后提交。</p><p>删除有两种方式</p><ul><li>第一种是简单的从暂存区中删除。但是文件还在被跟踪着。</li><li>第二种是直接在未暂存区域中移除文件，表示直接将文件移除版本控制中。不再跟踪</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm [<span class="string">-f | --force</span>][<span class="symbol">-n</span>] [<span class="string">-r</span>][<span class="symbol">--cached</span>] [<span class="string">--ignore-unmatch</span>][<span class="symbol">--quiet</span>] [--] <span class="xml"><span class="tag">&lt;<span class="name">file</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果删除文件之前文件修改过并且已经放入了暂存区域，则必须使用强制删除选项<code>-f</code> 才能将其删除。主要是为了防止误删。</li><li>当我们想要将文件从 Git 仓库中删除但是却想让他仍在我们的工作区域中时，（即保存在本地磁盘并且不被 Git 跟踪），为了达到这一目的，使用 <code>--cached</code> 选项</li><li>如果单纯执行rm,它虽然从磁盘删除，但是git依旧追踪，即远程仓库没有改变】</li></ul><h3 id="git-stash-备份"><a href="#git-stash-备份" class="headerlink" title="git stash 备份"></a>git stash 备份</h3><p>​    当我们已经在一个分支上修改文件后，如果必须要切换到其他分支展开其他的工作，而当前分支的工作还没有完成，此时我们需要使用 <code>$ git stash</code> 或 <code>$ git stash save</code> 命令将当前分支上的工作暂存到栈上，这时你的工作目录就干净了，就可以切换到其他分支工作，等工作完成后，再切换回原来的分支，可以使用 <code>$ git stash apply</code> 将你刚刚的储藏重新应用。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</span><br><span class="line"></span><br><span class="line">git stash <span class="keyword">pop</span>: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，<span class="keyword">pop</span>会从最近的一个stash中读取内容并恢复。</span><br><span class="line"></span><br><span class="line">git stash <span class="keyword">pop</span> –<span class="keyword">index</span> stash@&#123;0&#125;: 恢复编号为<span class="number">0</span>的进度的工作区和暂存区。</span><br><span class="line"></span><br><span class="line">git stash apply stash@&#123;1&#125; 以将你指定版本号为stash@&#123;1&#125;的工作取出来</span><br><span class="line"></span><br><span class="line">git stash drop[] 删除某一个进度，默认删除最新进度</span><br><span class="line"></span><br><span class="line">git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</span><br><span class="line"></span><br><span class="line">git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了</span><br></pre></td></tr></table></figure><h3 id="git-log-查看提交历史"><a href="#git-log-查看提交历史" class="headerlink" title="git log 查看提交历史"></a>git log 查看提交历史</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">选项                说明</span><br><span class="line">-p                按补丁格式显示每个更新之间的差异。</span><br><span class="line"><span class="comment">--stat            显示每次更新的文件修改统计信息。</span></span><br><span class="line"><span class="comment">--shortstat       只显示 --stat 中最后的行数修改添加移除统计。</span></span><br><span class="line"><span class="comment">--name-only       仅在提交信息后显示已修改的文件清单。</span></span><br><span class="line"><span class="comment">--name-status 显示新增、修改、删除的文件清单。</span></span><br><span class="line"><span class="comment">--abbrev-commit   仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</span></span><br><span class="line"><span class="comment">--relative-date   使用较短的相对时间显示（比如，“2 weeks ago”）。</span></span><br><span class="line"><span class="comment">--graph           显示 ASCII 图形表示的分支合并历史。</span></span><br><span class="line"><span class="comment">--pretty      使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</span></span><br></pre></td></tr></table></figure><p>常用选项 <code>-p</code> ,用来显示每次提交的内容差异，可以加上 -2 来仅仅显示最近两次提交。现在一般都是用工具或者在网上直接看记录</p><h3 id="Git-Branch-分支创建（合并分支和分离HEAD）"><a href="#Git-Branch-分支创建（合并分支和分离HEAD）" class="headerlink" title="Git Branch 分支创建（合并分支和分离HEAD）"></a>Git Branch 分支创建（合并分支和分离HEAD）</h3><p>​    Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：</p><blockquote><p>早建分支！多用分支！</p></blockquote><p>​    这是因为即使创建再多分的支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 查看本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="meta"># 创建本地分支(注意新分支创建后不会自动切换为当前分支)</span></span><br><span class="line">git branch [name]</span><br><span class="line"></span><br><span class="line"><span class="meta"># 切换分支</span></span><br><span class="line">git checkout [name]</span><br><span class="line"></span><br><span class="line"><span class="meta"># 创建新分支并立即切换到新分支</span></span><br><span class="line">git checkout -b [name]</span><br><span class="line"></span><br><span class="line"><span class="meta"># 强制删除一个分支</span></span><br><span class="line">git branch -D [name]</span><br><span class="line"></span><br><span class="line"><span class="meta"># 移动分支</span></span><br><span class="line">git branch -f master HEAD^</span><br></pre></td></tr></table></figure><p>​    Git 创建新分支的本质就是创建一个可以移动的新的指针。比如创建一个 testing 分支。<code>$ git branch testing</code> 这会在当前所提交的对象上创建一个指针，此时如图</p><p><img src="/2019/05/26/项目管理/git知识点/2.png" alt></p><h3 id="git-merge-amp-git-rebase-合并分支"><a href="#git-merge-amp-git-rebase-合并分支" class="headerlink" title="git merge&amp;git rebase  合并分支"></a>git merge&amp;git rebase  合并分支</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支<span class="number">1</span> 分支<span class="number">2</span></span><br><span class="line">git rebase   复制到目标分支 被复制分支</span><br></pre></td></tr></table></figure><p><img src="/2019/05/26/项目管理/git知识点/3.png" alt></p><p>git merge是将两个分支合并会生成一个新的节点，原来的分支没有了</p><p>git rebase 不会生成新的节点，是将两个分支融合成一个线性的提交。</p><ul><li>解决冲突时。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit就可以了。而<code>rebase</code>操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行<code>git rebase –continue</code>继续操作，或者<code>git rebase –skip</code>忽略冲突。</li></ul><h3 id="git-reset-amp-git-revert-撤销变更"><a href="#git-reset-amp-git-revert-撤销变更" class="headerlink" title="git reset&amp;git revert 撤销变更"></a>git reset&amp;git revert 撤销变更</h3><p>git revert<code>是用一次新的commit来回滚之前的commit，</code>git reset`是直接删除指定的commit。</p><p><strong>注意相对位置不同</strong></p><p>git reset HEAD^            撤销前一次commit</p><p>git reset HEAD            撤销前一次commit</p><p><strong>注意merge不同</strong></p><ul><li>reset相当于将HEAD指针往前移动，将HEAD指向的位置改变为之前存在的某个版本。（远程老commit还在,push的时候会merge）</li><li>revert相当于使用一次逆向的commit“中和”之前的提交，创建一个新的状态(push的时候不会在和远程老commit进行Merge)。</li></ul><p>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是<code>git reset</code>是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> –mixed <span class="keyword">id</span>: 回退一个版本,且会将暂存区的内容和本地已提交的内容全部恢复到未暂存的状态,不影响原来本地文件(未提交的也 不受影响) </span><br><span class="line">git <span class="keyword">reset</span> –soft <span class="keyword">id</span>: 回退一个版本,不清空暂存区,将已提交的内容恢复到暂存区,不影响原来本地的文件(未提交的也不受影响) </span><br><span class="line">git <span class="keyword">reset</span> –herd <span class="keyword">id</span>: 回退一个版本,清空暂存区,将已提交的内容的版本恢复到本地,本地的文件也将被恢复的版本替换</span><br></pre></td></tr></table></figure><h3 id="git-cherry-pick-整理提交记录"><a href="#git-cherry-pick-整理提交记录" class="headerlink" title="git cherry-pick 整理提交记录"></a>git cherry-pick 整理提交记录</h3><p>​     cherry-pick的作用是，将某次或者某几次的提交,在另一个分支上进行重演。(并不想合并而是想拿一些修改状态过来)</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick commitid1 commitid2 commitid3 <span class="comment"># 多个哈希值空格分开</span></span><br><span class="line">git cherry-pick commitid1.<span class="string">..commitid3</span><span class="comment"># ...表示取两个哈希值区间所有状态（不包含第一个commitid）</span></span><br></pre></td></tr></table></figure><blockquote><p>看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>master</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>master</code> 分支上，但这样的话 <code>master</code> 分支就会包含我这些调试语句了。实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用git merge两个分支就可以了</p></blockquote><h3 id="git-fetch-远程下载"><a href="#git-fetch-远程下载" class="headerlink" title="git fetch 远程下载"></a>git fetch 远程下载</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin <span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>o/master</code>)</li></ul><p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态,它不会改变你的本地仓库，也不会改变你的分支.如果不带参数，它将下载所有远程提交记录</p><p>既然我们已经知道了如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p><ul><li><code>git cherry-pick o/master</code></li><li><code>git rebase o/master</code></li><li><code>git merge o/master</code></li><li>等等</li></ul><p>也就是说你可以选你喜欢的进行合并</p><h3 id="git-push-提交到远程"><a href="#git-push-提交到远程" class="headerlink" title="git push 提交到远程"></a>git push 提交到远程</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;source&gt;<span class="symbol">:&lt;destination&gt;</span></span><br></pre></td></tr></table></figure><p>git push 提交成功之后本地对应的远程分支也会对应更新</p><h3 id="git-tag-版本标签"><a href="#git-tag-版本标签" class="headerlink" title="git tag 版本标签"></a>git tag 版本标签</h3><p>主要就是用于release的时候进行标记。</p><p>1.添加标签： git tag -a version -m “note”<br>注解：git tag 是打标签的命令，-a 是添加标签，其后要跟新标签号，-m 及后面的字符串是对该标签的注释。</p><p>2.提交标签到远程仓库 ：git push origin -tags<br>注解：就像git push origin master 把本地修改提交到远程仓库一样，-tags可以把本地的打的标签全部提交到远程仓库。</p><p>3.删除标签：git tag -d version<br>注解：-d 表示删除，后面跟要删除的tag名字</p><p>4.删除远程标签：git push origin :refs/tags/version<br>注解：就像git push origin :branch_1 可以删除远程仓库的分支branch_1一样， 冒号前为空表示删除远程仓库的tag。</p><p>5.查看标签：git tag或者git tag -l</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-a</span> v0.<span class="number">1.1</span> <span class="literal">master</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h2 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识"></a>进阶知识</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/2019/05/26/项目管理/git知识点/1.png" alt></p><p>要查看哪些文件处于什么状态，可以用 git status 命令</p><p>Git 有四种状态，你的文件可能处于其中之一：</p><ul><li><strong>Untracked</strong>: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<code>git add</code> 状态变为<code>Staged</code>.</li><li><strong>Unmodify</strong>: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为<code>Modified</code>. 如果使用<code>git rm</code>移出版本库, 则成为<code>Untracked</code>文件</li><li><strong>Modified</strong>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过<code>git add</code>可进入暂存<code>staged</code>状态, 使用<code>git checkout</code> 则丢弃修改过, 返回到<code>unmodify</code>状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改</li><li><strong>Staged</strong>: 暂存状态. 执行<code>git commit</code>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为<code>Unmodify</code>状态. 执行<code>git reset HEAD filename</code>取消暂存, 文件状态为<code>Modified</code></li></ul><p>Git 有三种工作区域，你的文件可能处于其中之一：</p><ul><li><p>工作目录 Working Directory ：对项目的某个版本独立提取出来的内容，这些从Git仓库的压缩数据库提取出来的文件，放在磁盘上供你使用或修改。</p></li><li><p>暂存区域 Staging Area ：是<strong>一个文件</strong>，<strong>保存了下次将提交的文件列表</strong>，是待提交文件的暂存区域。一般在Git仓库的目录中，有时也被称为索引。</p></li><li><p>Git仓库：用来保存项目的元数据和对象数据库的地方。是Git中最重要的部分，从其他计算机克隆仓库时拷贝的就是这里的数据</p></li></ul><h3 id="忽略内容"><a href="#忽略内容" class="headerlink" title="忽略内容"></a>忽略内容</h3><p>新建一个.gitignore 的文件，列出要忽略的文件模式。<br> 文件 .gitignore 的格式规范如下：</p><p>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</p><p>可以使用标准的 glob 模式匹配。</p><p>匹配模式可以以（/）开头防止递归。</p><p>匹配模式可以以（/）结尾指定目录。</p><p>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># no .a files  忽略所有.a结尾的文件</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line">\<span class="comment"># but do track lib.a, even though you're ignoring .a files above，被忽略的.a文件中不包括lib.a文件</span></span><br><span class="line">!<span class="class"><span class="keyword">lib</span>.<span class="title">a</span></span></span><br><span class="line"></span><br><span class="line">\<span class="comment"># only ignore the TODO file in the current directory, not subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line">\<span class="comment"># ignore all files in the build/ directory</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line">\<span class="comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line">\<span class="comment"># ignore all .pdf files in the doc/ directory</span></span><br><span class="line">doc/**<span class="regexp">/*.pdf</span></span><br></pre></td></tr></table></figure><h3 id="分离HEAD"><a href="#分离HEAD" class="headerlink" title="分离HEAD"></a>分离HEAD</h3><p>​    HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p><p>如何判断 Git 当前在哪一个分支？此时就要依靠 HEAD 指针。该指针指向当前所在的本地分支。当HEAD指向一个分支的时候，会变成’分支*’，否则会以HEAD-&gt;形式存在。</p><p>如图</p><p><img src="/2019/05/26/项目管理/git知识点/5.png" alt="img"></p><h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><p>指定某个状态可以用其哈希码，不过哈希码共40位。解决办法有两个：</p><ul><li><p>it 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入<code>fed2</code> 而不是一长串字符</p></li><li><p>相对引用（要有一个作为基准，如master或其他分支）：</p><ul><li><p>使用 <code>^&lt;num&gt;</code>向上一层水平移动多个提交记录</p></li><li><p>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></p></li></ul></li></ul><h3 id="Git-Flow简介"><a href="#Git-Flow简介" class="headerlink" title="Git Flow简介"></a>Git Flow简介</h3><p>​    功能驱动式开发”（Feature-driven development，简称FDD）。它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。</p><p>​    它最主要的特点有两个。首先，项目存在两个长期分支，分别是：主分支master、开发分支develop。其次，项目存在三种短期分支，分别是：功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch），一旦完成开发，它们就会被合并进develop或master，然后被删除。</p><ul><li><code>Production</code>分支。也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改。</li><li><code>Develop</code>分支。这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支。</li><li><code>Feature</code>分支。这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。</li><li><code>Release</code>分支。当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。</li><li><code>Hotfix</code>分支。当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git 知识点整理&lt;/p&gt;
    
    </summary>
    
      <category term="项目管理" scheme="http://kodgv.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="http://kodgv.xyz/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>linux装软件</title>
    <link href="http://kodgv.xyz/2019/05/24/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/linux%E8%A3%85%E8%BD%AF%E4%BB%B6/"/>
    <id>http://kodgv.xyz/2019/05/24/项目管理/linux装软件/</id>
    <published>2019-05-24T13:29:03.000Z</published>
    <updated>2019-07-19T12:24:59.890Z</updated>
    
    <content type="html"><![CDATA[<p>Linux下的装软件历程</p><a id="more"></a><p>搜狗拼音：<a href="https://blog.csdn.net/lupengCSDN/article/details/80279177" target="_blank" rel="noopener">https://blog.csdn.net/lupengCSDN/article/details/80279177</a></p><p>java安装：<a href="http://www.manongjc.com/article/34273.html" target="_blank" rel="noopener">http://www.manongjc.com/article/34273.html</a></p><p>extundelete:恢复删除文件（先安装才能恢复）</p><p>linux命令：<a href="https://wangchujiang.com/linux-command/list.html#!kw=%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener">https://wangchujiang.com/linux-command/list.html#!kw=%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95</a></p><p>docker远程服务器连接：<a href="https://blog.csdn.net/hanchaobiao/article/details/84069299" target="_blank" rel="noopener">https://blog.csdn.net/hanchaobiao/article/details/84069299</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux下的装软件历程&lt;/p&gt;
    
    </summary>
    
      <category term="项目管理" scheme="http://kodgv.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="linux" scheme="http://kodgv.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux习题</title>
    <link href="http://kodgv.xyz/2019/05/21/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Linux%E4%B9%A0%E9%A2%98/"/>
    <id>http://kodgv.xyz/2019/05/21/项目管理/Linux习题/</id>
    <published>2019-05-21T12:43:44.000Z</published>
    <updated>2019-06-17T11:44:19.827Z</updated>
    
    <content type="html"><![CDATA[<p>Linux收集习题</p><a id="more"></a><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>1.请问如果我以文字模式登陆Linux主机时，我有几个终端机接口可以使用？如何切换各个不同的终端机接口？</p><p>​    共有六个， tty1 ~ tty6 ，切换的方式为 Crtl + Alt + [F1]~[F6]（六个终端无区别，只是为了避免某个终端程序卡死）</p><p>2.在Linux系统中，/VBird与/vbird是否为相同的文件？</p><p>​    两者为不同的文件，因为 Linux 系统中，大小写字母代表意义不一样！</p><p>3.Linux 提供相当多的线上查询，称为 man page，请问，我如何知道系统上有多少关于 passwd 的说明？</p><p>​    man -f passwd（查看man file的数量）</p><p>4.我使用dmtsai这个帐号登陆系统了，请问我能不能使用reboot来重新开机？ </p><p>​    理论上reboot仅能让root执行。不过，如果dmtsai是在主机前面以图形接口登陆时，则dmtsai还是可以通过图形接口功能来关机。</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="　第五章"></a>　第五章</h2><p>1.请问testgroup这个群组的成员与其他人（others）是否可以进入本目录？</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr--  <span class="number"> 1 </span>test1    testgroup   <span class="number"> 5238 </span>Jun<span class="number"> 19 </span>10:25 groups/</span><br></pre></td></tr></table></figure><ul><li><p>文件拥有者test1[rwx]可以在本目录中进行任何工作；</p></li><li><p>而testgroup这个群组[r-x]的帐号，例如test2, test3亦可以进入本目录进行工作，但是不能在本目录下进行写入的动作；</p></li><li><p>至于other的权限中[r—]虽然有r ，但是由于没有x的权限，因此others的使用者，并不能进入此目录！</p></li></ul><p>打开该目录就是执行ｘ</p><p>2.当一个一般文件权限为 -rwxrwxrwx 则表示这个文件的意义为？</p><p>任何人皆可读取、修改或编辑、可以执行，但不一定能删除。</p><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><p>一、让使用者能进入某目录成为“可工作目录”的基本权限为何：</p><ul><li>可使用的指令：例如 cd 等变换工作目录的指令；</li><li>目录所需权限：使用者对这个目录至少需要具有 x 的权限</li><li>额外需求：如果使用者想要在这个目录内利用 ls 查阅文件名，则使用者对此目录还需要 r 的权限。</li></ul><p>二、使用者在某个目录内读取一个文件的基本权限为何？</p><ul><li>可使用的指令：例如本章谈到的 cat, more, less等等</li><li>目录所需权限：使用者对这个目录至少需要具有 x 权限；</li><li>文件所需权限：使用者对文件至少需要具有 r 的权限才行！</li></ul><p>三、让使用者可以修改一个文件的基本权限为何？</p><ul><li>目录所需权限：使用者在该文件所在的目录至少要有 x 权限；</li><li>文件所需权限：使用者对该文件至少要有 r, w 权限</li></ul><p>四、让一个使用者可以创建一个文件的基本权限为何？</p><ul><li>目录所需权限：使用者在该目录要具有 w,x 的权限，重点在 w 啦！</li></ul><p>例题：让一个使用者 dmtsai 能够进行“cp /dir1/file1 /dir2”的指令时，请说明 dir1, file1, dir2 的最小所需权限为何？</p><ul><li>dir1 ：至少需要有 x 权限；</li><li>file1：至少需要有 r 权限；</li><li>dir2 ：至少需要有 w, x 权限。</li></ul><p>例题：有一个文件全名为 /home/student/www/index.html ，各相关文件/目录的权限如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x<span class="number"> 23 </span>root    root   <span class="number"> 4096 </span>Sep<span class="number"> 22 </span>12:09 /</span><br><span class="line">drwxr-xr-x <span class="number"> 6 </span>root    root   <span class="number"> 4096 </span>Sep<span class="number"> 29 </span>02:21 /home</span><br><span class="line">drwx------ <span class="number"> 6 </span>student student<span class="number"> 4096 </span>Sep<span class="number"> 29 </span>02:23 /home/student</span><br><span class="line">drwxr-xr-x <span class="number"> 6 </span>student student<span class="number"> 4096 </span>Sep<span class="number"> 29 </span>02:24 /home/student/www</span><br><span class="line">-rwxr--r-- <span class="number"> 6 </span>student student <span class="number"> 369 </span>Sep<span class="number"> 29 </span>02:27 /home/student/www/index.html</span><br></pre></td></tr></table></figure><p>请问 vbird 这个帐号（不属于student群组）能否读取 index.html 这个文件呢?</p><p>答：虽然 www 与 index.html 是可以让 vbird 读取的权限，但是因为目录结构是由根目录一层一层读取的， 因此 vbird 可进入 /home 但是却不可进入 /home/student/ ，既然连进入 /home/student 都不许了， 当然就读不到 index.html 了！所以答案是“vbird不会读取到 index.html 的内容”喔！</p><ul><li>找出 /etc 下面，文件大小介于 50K 到 60K 之间的文件，并且将权限完整的列出 （ls -l）：find /etc -size +50k -a -size -60k -exec ls -l {} \; 注意到 -a ，那个 -a 是 and 的意思，为符合两者才算成功</li><li>找出 /etc 下面，文件大小大于 50K 且文件所属人不是 root 的文件名，且将权限完整的列出 （ls -l）；find /etc -size +50k -a ! -user root -exec ls -ld {} \; find /etc -size +50k -a ! -user root -type f -exec ls -l {} \; 上面两式均可！注意到 ! ，那个 ! 代表的是反向选择，亦即“不是后面的项目”之意！</li><li>找出 /etc 下面，容量大于 1500K 以及容量等于 0 的文件：find /etc -size +1500k -o -size 0 相对于 -a ，那个 -o 就是或 （or） 的意思啰！</li></ul><h3 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h3><ol><li>请在 /tmp 这个目录下创建一个名为 vitest 的目录；</li><li>进入 vitest 这个目录当中；</li><li>将 /etc/man_db.conf 复制到本目录下面（或由上述的链接下载 <a href="http://linux.vbird.org/linux_basic/0310vi/man_db.conf" target="_blank" rel="noopener">man_db.conf</a> 文件）；</li><li>使用 vi 打开本目录下的 man_db.conf 这个文件；</li><li>在 vi 中设置一下行号；</li><li>移动到第 43 列，向右移动 59 个字符，请问你看到的小括号内是哪个文字？</li><li>移动到第一列，并且向下搜寻一下“ gzip ”这个字串，请问他在第几列？</li><li>接着下来，我要将 29 到 41 列之间的“小写 man 字串”改为“大写 MAN 字串”，并且一个一个挑选是否需要修改，如何下达指令？如果在挑选过程中一直按“y”， 结果会在最后一列出现改变了几个 man 呢？</li><li>修改完之后，突然反悔了，要全部复原，有哪些方法？</li><li>我要复制 66 到 71 这 6 列的内容（含有MANDB_MAP），并且贴到最后一列之后；</li><li>113 到 128 列之间的开头为 # 符号的注解数据我不要了，要如何删除？</li><li>将这个文件另存成一个 man.test.config 的文件名；</li><li>去到第 25 列，并且删除 15 个字符，结果出现的第一个单字是什么？</li><li>在第一列新增一列，该列内容输入“I am a student…”；</li><li>储存后离开吧！</li></ol><p>整个步骤可以如下显示：</p><ol><li>“mkdir /tmp/vitest”</li><li>“cd /tmp/vitest”</li><li>“cp /etc/man_db.conf .”</li><li>“/bin/vi man_db.conf”</li><li>“:set nu”然后你会在画面中看到左侧出现数字即为行号。</li><li>先按下“43G”再按下“59→”会看到“ as ”这个单字在小括号内；</li><li>先执行“1G”或“gg”后，直接输入“/gzip”，则会去到第 93 列才对！</li><li>直接下达“ :29,41s/man/MAN/gc ”即可！若一直按“y”最终会出现“在 13 列内置换 13 个字串”的说明。</li><li>（1）简单的方法可以一直按“ u ”回复到原始状态，（2）使用不储存离开“ :q! ”之后，再重新读取一次该文件；</li><li>“66G” 然后再“ 6yy ”之后最后一列会出现“复制6列”之类的说明字样。 按下“ G ”到最后一列，再给他“ p ”贴上6列！</li><li>因为 113~128 共 16 列，因此“ 113G ”→“ 16dd ”就能删除 16 列，此时你会发现光标所在 113 列的地方变成 “ # Flags. ” 开头啰</li><li>“ :w man.test.config ”，你会发现最后一列出现 “man.test.config” [New].. 的字样。</li><li>“25G” 之后，再给他“ 15x ”即可删除 15 个字符，出现“ tree ”的字样；</li><li>先“ 1G ”去到第一列，然后按下大写的“ O ”便新增一列且在插入模式；开始输入“I am a student…”后， 按下[Esc]回到一般指令模式等待后续工作；</li><li>“:wq”</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux收集习题&lt;/p&gt;
    
    </summary>
    
      <category term="项目管理" scheme="http://kodgv.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="linux" scheme="http://kodgv.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱综述</title>
    <link href="http://kodgv.xyz/2019/05/17/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BB%BC%E8%BF%B0/"/>
    <id>http://kodgv.xyz/2019/05/17/知识图谱/知识图谱综述/</id>
    <published>2019-05-17T07:28:31.000Z</published>
    <updated>2019-05-25T12:46:03.990Z</updated>
    
    <content type="html"><![CDATA[<p>知识图谱学习整理的一些概念和小知识点</p><a id="more"></a><p>[TOC]</p><h2 id="知识图谱首要"><a href="#知识图谱首要" class="headerlink" title="知识图谱首要"></a>知识图谱首要</h2><ol><li>What are the <em>nodes</em>? In a knowledge graph, they will be related to semantic concepts such as persons, entities, events <em>etc.</em></li><li>What are the <em>edges</em>? They will be defined by <em>relationships</em> between nodes based on semantics.</li><li>Once you answered these two key questions, you can go to the next phase which is the <em>data acquisition strategy</em>.</li></ol><p>In general, there are two main ways of going about knowledge processing:</p><ol><li><strong>Simple heuristic approaches</strong> such as text processing based on regular expressions, simple parsing and NLP techniques. For images, this approach includes basic processing of metadata. The lack of depth in this approach can be compensated and mitigated by sheer numbers <em>i.e.</em> throwing lots and lots of data at it to cherry pick low hanging fruit.</li><li><strong>Deep learning</strong> techniques where you employ novel methods to experiment with your own kinds of knowledge. This will be great fun and you will be on the leading edge but you should also keep in mind that the edge is (b)leading too. Just do not let that deter you and keep moving through growing pains.</li></ol><p><a href="http://kns.cnki.net/KCMS/detail/11.5602.TP.20190517.1335.002.html?uid=WEEvREcwSlJHSldRa1FhdXNXaEd2Um5XT2VCQXJTY3JoN1JsS2FvQXpYYz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MjEwNDNxRkNubFc3dkFKVjQ9TGpYZmZiRzRIOWpNcW81Q1pPc1BZdzlNem1SbjZqNTdUM2ZscVdNMENMTDdSN3FlYnVa" target="_blank" rel="noopener">民航突发事件领域本体关系提取方法的研究</a></p><ul><li><p>非结构化数据可以整理为半结构化数据：</p><p>将突发事件的文本信息整理为标题、时间、航班号、事<br>件描述的半结构化形式，将事件发生时间和航班号作为事件<br>的唯一标识；</p></li><li><p>关系标注：attribute-of/reason-of/result-of</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://arxiv.org/pdf/1503.00759v1.pdf" target="_blank" rel="noopener">知识图谱开山基础</a></p><p><a href="https://kgtutorial.github.io/" target="_blank" rel="noopener">知识图谱教程</a></p><p><a href="http://blog.itpub.net/31562039/viewspace-2286939/" target="_blank" rel="noopener">事理图谱</a>以因果关系作为关系进行的推理</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>keypoint is how to define the relation</li><li>两侧实体的类型已经定义，关系好像已经没有定义的意义，问题好像不是知识图谱的问题，是实体的问题，现在是FILED-VALUE-REAL 我们尝试想用一个关系描述两个横线，甚至这两个横线的关系还不一定是一样的。</li></ul><ul><li><p>需要做的：</p><p>如何提取实体：</p></li></ul><p>  在民航领域，基于领域本体的突发事件应急管理已经取<br>  得了初步的成果[19-23]，民航突发事件领域本体的关系提取方<br>  法主要有基于 NNV 关联规则的方法[20]、基于改进的层次聚<br>  类 H_cluster 的方法[21]、基于 LDA 的方法[22]和基于 LSTM 的<br>  方法[23]。其中，基于 NNV 的方法将关联规则与自然语言处<br>  理方法相结合，完善了领域词典的构建方法、增添同义词表、<br>  丰富领域术语的过滤过程，利用关联规则法提取事务集，计<br>  算概念和非分类关系的支持度和置信度，解决了领域本体非<br>  分类关系获取中无法自动获取关系名称的问题，相较于模式<br>  匹配方法提取结果更好。但由于中文概念的多义性对非分类<br>  关系种类的影响等原因，该方法的准确率和召回率都很低；<br>  基于改进的层次聚类 H_cluster 的方法在概念获取的基础上，<br>  根据领域概念的上下文构建概念向量空间，计算概念相似度，<br>  解决了聚类结果的粒度过细问题，使其更加符合本体层次结<br>  构的需要，实现了概念间分类关系的提取，但该方法的自动<br>  化程度有限，且准确率和召回率均提升较小；基于 LDA 的<br>  方法以航空安全事件文本信息作为数据源，采用 NLPIR 自适<br>  应分词与过滤方法获取候选术语集，设计了领域本体的 LDA<br>  主题模型，通过吉布斯采样进行 LDA 模型训练与主题推断，<br>  实现了领域本体核心概念与关系的提取，可以有效解决大规<br>  模领域本体的自动更新问题。由于领域本体所有概念及其语<br>  义关系的复杂性，基于 LDA 概率分布的规则构建与本体实<br>  例自动获取的方法应进一步深入研究；基于 LSTM 的方法将<br>  深度学习模型 LSTM 应用于领域本体关系提取，首先将文本<br>  信息向量化，提取文本局部特征，然后将文本局部特征导入<br>  LSTM 模型中，获取文本整体特征，再将局部特征和整体特<br>  征进行特征融合，通过分类器进行分类。相较于传统方法，<br>  该方法能更加充分利用句子中的语义信息，更准确地表达深<br>  层语义，因此关系提取的 F 值有了较大提升，但还可以进一<br>  步优化。此外，当前互联网上包含越来越多的民航突发事件<br>  信息，涉及不同信息源(微博、微信、航空安全自愿报告系统<br>  等)对事件的不同评论，结构和内容越来越复杂，且民航突发<br>  事件领域本体的，因此迫切需要更加有效的关系抽取方法来<br>  支撑领域本体的自动构建</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;知识图谱学习整理的一些概念和小知识点&lt;/p&gt;
    
    </summary>
    
      <category term="知识图谱" scheme="http://kodgv.xyz/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
      <category term="知识图谱" scheme="http://kodgv.xyz/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://kodgv.xyz/2019/05/16/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%B8%9F%E5%8F%94/"/>
    <id>http://kodgv.xyz/2019/05/16/项目管理/鸟叔/</id>
    <published>2019-05-16T12:54:54.000Z</published>
    <updated>2019-07-05T11:32:05.045Z</updated>
    
    <content type="html"><![CDATA[<p>Linux学习</p><a id="more"></a><p>[TOC]<br><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/49.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/49.html</a></p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ul><li>显示日期与时间的指令： date</li><li>显示日历的指令： cal [month] [year]</li><li>简单好用的计算器： bc</li></ul><h3 id="基础快捷键"><a href="#基础快捷键" class="headerlink" title="基础快捷键"></a>基础快捷键</h3><ul><li>tab补全： 命令补全；文件补全；选项补全(—)</li><li>ctrl+c:强制结束</li><li>ctrl+d:离开命令行</li><li>[shift]+{[PageUP]|[Page Down]}按键：上下翻页，仅限在命令行内</li></ul><h3 id="查询命令帮助"><a href="#查询命令帮助" class="headerlink" title="查询命令帮助"></a>查询命令帮助</h3><blockquote><p>man 命令<br>man page</p></blockquote><div class="table-container"><table><thead><tr><th>代号</th><th>内容说明</th></tr></thead><tbody><tr><td>NAME</td><td>简短的指令、数据名称说明</td></tr><tr><td>SYNOPSIS</td><td>简短的指令下达语法（syntax）简介</td></tr><tr><td>DESCRIPTION</td><td>较为完整的说明，这部分最好仔细看看！</td></tr><tr><td>OPTIONS</td><td>针对 SYNOPSIS 部分中，有列举的所有可用的选项说明</td></tr><tr><td>COMMANDS</td><td>当这个程序（软件）在执行的时候，可以在此程序（软件）中下达的指令</td></tr><tr><td>FILES</td><td>这个程序或数据所使用或参考或链接到的某些文件</td></tr><tr><td>SEE ALSO</td><td>可以参考的，跟这个指令或数据有相关的其他说明！</td></tr><tr><td>EXAMPLE</td><td>一些可以参考的范例</td></tr></tbody></table></div><blockquote><p>info 命令</p></blockquote><p>​    可读性会强很多，只是可能有些命令查不到，光标移到节点</p><ul><li>回车可进入</li><li>U返回上一节点</li><li>N进入下一节点</li><li>P进入上 一节点</li></ul><h3 id="正确的关机"><a href="#正确的关机" class="headerlink" title="正确的关机"></a>正确的关机</h3><p>关机前需要检查：</p><ul><li><p>who  看谁在线上</p></li><li><p>netstat -a 网络连线状态</p></li><li><p>ps -aux 查看背景执行程序</p></li><li><p>sync 将内存数据写入硬盘（很重要！）</p><p>因此在Linux系统中，为了加快数据的读取速度，所以在默认的情况中， 某些已经载入内存中的数据将不会直接被写回硬盘，而是先暂存在内存当中，如此一来， 如果一个数据被你重复的改写，那么由于他尚未被写入硬盘中，因此可以直接由内存当中读取出来， 在速度上一定是快上相当多的！</p></li></ul><p>需要以root执行，一般可以推迟一会关机，以免出错</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@study</span> ~]<span class="meta"># shutdown -h now</span></span><br><span class="line">立刻关机，其中 now 相当于时间为 <span class="number">0</span> 的状态</span><br><span class="line">[root<span class="symbol">@study</span> ~]<span class="meta"># shutdown -h 20:25</span></span><br><span class="line">系统在今天的 <span class="number">20</span>:<span class="number">25</span> 分会关机，若在<span class="number">21</span>:<span class="number">25</span>才下达此指令，则隔天才关机</span><br><span class="line">[root<span class="symbol">@study</span> ~]<span class="meta"># shutdown -h +10</span></span><br><span class="line">系统再过十分钟后自动关机</span><br><span class="line">[root<span class="symbol">@study</span> ~]<span class="meta"># shutdown -r now</span></span><br><span class="line">系统立刻重新开机</span><br><span class="line">[root<span class="symbol">@study</span> ~]<span class="meta"># shutdown -r +30 <span class="string">'The system will reboot'</span> </span></span><br><span class="line">再过三十分钟系统会重新开机，并显示后面的讯息给所有在线上的使用者</span><br><span class="line">[root<span class="symbol">@study</span> ~]<span class="meta"># shutdown -c 取消关机</span></span><br></pre></td></tr></table></figure><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>文件可存取身份三个类别：owner/group/others</p><p>可存取的权限：read/write/execute</p><h3 id="使用者与群组"><a href="#使用者与群组" class="headerlink" title="使用者与群组"></a>使用者与群组</h3><p>文件拥有者owner</p><p>Linux是个多用户多任务的系统，因此可能常常会有多人同时使用这部主机来进行工作的情况发生， 为了考虑每个人的隐私权以及每个人喜好的工作环境，因此，这个“文件拥有者”的角色就显的相当的重要。其他人无法查看你的文件</p><p>群组概念group</p><p>团队开发的时候，不同的团队在同一台主机上开发。</p><ul><li>使用者的意义：由于王家三人各自拥有自己的房间，所以， 王二毛虽然可以进入王三毛的房间，但是二毛不能翻三毛的抽屉喔！那样会被三毛K的！ 因为抽屉里面可能有三毛自己私人的东西，例如情书啦，日记啦等等的，这是“私人的空间”，所以当然不能让二毛拿啰！</li><li>群组的概念：由于共同拥有客厅，所以王家三兄弟可以在客厅打开电视机啦、 翻阅报纸啦、坐在沙发上面发呆啦等等的！ 反正，只要是在客厅的玩意儿，三兄弟都可以使用喔！ 因为大家都是一家人嘛！但是隔壁老王就不能进来。</li></ul><p>其他人的概念other</p><p>非同一群组的人，都叫其他人。因为它们相对别人来说都只是‘其他人’</p><p>天神root</p><p>可以有绝对权力，无视一切规则</p><ul><li>系统上的帐号与一般身份使用者储存在/etc/passwd</li><li>个人的密码/etc/shadow</li><li>群组名称/etc/group</li></ul><p>这三个配置文件的具体内容第十三章继续讲，很复杂的</p><h3 id="Linux-文件权限"><a href="#Linux-文件权限" class="headerlink" title="Linux 文件权限"></a>Linux 文件权限</h3><p>ls -al</p><p>这行信息要好好记住</p><p><img src="/2019/05/16/项目管理/鸟叔/E:/bolg/source/_posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Linux/1.gif" alt></p><p><img src="/2019/05/16/项目管理/鸟叔/E:/bolg\source\_posts\项目管理\Linux\2.gif" alt></p><ul><li>第一个字符代表这个文件是“目录、文件或链接文件等等”：<ul><li>当为[ d ]则是目录，例如<a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/Text/index.html#table2.1.1" target="_blank" rel="noopener">上表</a>文件名为“.config”的那一行；</li><li>当为[ - ]则是文件，例如<a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/Text/index.html#table2.1.1" target="_blank" rel="noopener">上表</a>文件名为“initial-setup-ks.cfg”那一行；</li><li>若是[ l ]则表示为链接文件（link file）；</li><li>若是[ b ]则表示为设备文件里面的可供储存的周边设备（可随机存取设备）；</li><li>若是[ c ]则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设备）。</li></ul></li><li>接下来的字符中，以三个为一组，且均为“rwx” 的三个参数的组合。<ul><li>r （read）：可读取此一文件的实际内容，如读取文本文件的文字内容等；</li><li>w （write）：可以编辑、新增或者是修改该文件的内容（<strong>但不含删除该文件</strong>）；</li><li>x （execute）：该文件具有可以被系统执行的权限。<br>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已</li><li>第一组为“文件拥有者可具备的权限”，以“initial-setup-ks.cfg”那个文件为例， 该文件的拥有者可以读写，但不可执行；</li><li>第二组为“加入此群组之帐号的权限”；</li><li>第三组为“非本人且没有加入本群组之其他帐号的权限”。</li></ul></li></ul><h3 id="改变文件属性与权限"><a href="#改变文件属性与权限" class="headerlink" title="改变文件属性与权限"></a>改变文件属性与权限</h3><p>查看文件权限：ls -l 文件名</p><p>查看文件夹权限：ls -ld 文件夹名</p><ul><li><p>chgrp ：改变文件所属群组        chgrp [-R] 群族名 dirname/filename</p></li><li><p>chown ：改变文件拥有者            chown [-R] 帐号名称 文件或目录</p></li><li><p>chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性   </p><p>chmod 644 .bashrc</p></li></ul><p>chgrp/chown应用场景，由于复制行为（cp）会复制执行者的属性与权限，所以当你想把文件给别人的时候，就会出现问题。</p><blockquote><p>r:4</p><p>w:2</p><p>x:1</p></blockquote><p>如果想rw-就是6，rwx就是7</p><h3 id="权限对目录的重要性"><a href="#权限对目录的重要性" class="headerlink" title="权限对目录的重要性"></a>权限对目录的重要性</h3><ul><li><p>r （read contents in directory）：</p><p>表示具有读取目录结构清单的权限，所以当你具有读取（r）一个目录的权限时，表示你可以查询该目录下的文件名数据。 所以你就可以利用 ls 这个指令将该目录的内容列表显示出来！</p></li><li><p>w （modify contents of directory）：</p><p>这个可写入的权限对目录来说，是很了不起的！ 因为他表示你具有异动该目录结构清单的权限，也就是下面这些权限：</p><ul><li>创建新的文件与目录；</li><li>删除已经存在的文件与目录（不论该文件的权限为何！）</li><li>将已存在的文件或目录进行更名；</li><li>搬移该目录内的文件、目录位置。 总之，目录的w权限就与该目录下面的文件名异动有关就对了啦！</li></ul></li><li><p>x （access directory）：</p><p>咦！目录的执行权限有啥用途啊？目录只是记录文件名而已，总不能拿来执行吧？没错！目录不可以被执行，目录的x代表的是使用者能否进入该目录，它相当于抽屉的钥匙，所以要想拿到抽屉里面的文件必须要先有钥匙。</p><p>| 元件 | 内容         | 叠代物件   | r            | w            | x                       |<br>| —— | —————— | ————— | —————— | —————— | ———————————- |<br>| 文件 | 详细数据data | 文件数据夹 | 读到文件内容 | 修改文件内容 | 执行文件内容            |<br>| 目录 | 文件名       | 可分类抽屉 | 读到文件名   | 修改文件名   | 进入该目录的权限（key） |</p></li></ul><h3 id="Linux目录配置的依据"><a href="#Linux目录配置的依据" class="headerlink" title="Linux目录配置的依据"></a>Linux目录配置的依据</h3><p>（需要筛选一遍重要的目录出来）</p><ul><li>/ （root, 根目录）：与开机系统有关；</li><li>/usr （unix software resource）：与软件安装/执行有关；</li><li>/var （variable）：与系统运行过程有关。</li></ul><p>根目录 （/） 的意义与内容</p><p>根目录是整个系统最重要的一个目录，它是系统的核心目录</p><div class="table-container"><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td>第一部份：FHS 要求必须要存在的目录</td><td></td></tr><tr><td>/bin</td><td>系统有很多放置可执行文件的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin下面的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</td></tr><tr><td>/boot</td><td>这个目录主要在放置开机会使用到的文件，包括Linux核心文件以及开机菜单与开机所需配置文件等等。 Linux kernel常用的文件名为：vmlinuz，如果使用的是grub2这个开机管理程序， 则还会存在/boot/grub2/这个目录喔！</td></tr><tr><td>/dev</td><td>在Linux系统上，任何设备与周边设备都是以文件的型态存在于这个目录当中的。 你只要通过存取这个目录下面的某个文件，就等于存取某个设备啰～ 比要重要的文件有/dev/null, /dev/zero, /dev/tty, /dev/loop<em>, /dev/sd</em>等等</td></tr><tr><td>/etc</td><td>系统主要的配置文件几乎都放置在这个目录内，例如人员的帐号密码档、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有root有权力修改。FHS建议不要放置可可执行文件（binary）在这个目录中喔。比较重要的文件有： /etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue 等等。另外 FHS 还规范几个重要的目录最好要存在 /etc/ 目录下喔：/etc/opt（必要）：这个目录在放置第三方协力软件 /opt 的相关配置文件 /etc/X11/（建议）：与 X Window 有关的各种配置文件都在这里，尤其是 xorg.conf 这个 X Server 的配置文件。 /etc/sgml/（建议）：与 SGML 格式有关的各项配置文件 /etc/xml/（建议）：与 XML 格式有关的各项配置文件</td></tr><tr><td>/lib</td><td>系统的函数库非常的多，而/lib放置的则是在开机时会用到的函数库， 以及在/bin或/sbin下面的指令会调用的函数库而已。 什么是函数库呢？你可以将他想成是“外挂”，某些指令必须要有这些“外挂”才能够顺利完成程序的执行之意。 另外 FSH 还要求下面的目录必须要存在：/lib/modules/：这个目录主要放置可抽换式的核心相关模块（驱动程序）喔！</td></tr><tr><td>/media</td><td>media是“媒体”的英文，顾名思义，这个/media下面放置的就是可移除的设备啦！ 包括软盘、光盘、DVD等等设备都暂时挂载于此。常见的文件名有：/media/floppy, /media/cdrom等等。</td></tr><tr><td>/mnt</td><td>如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。 在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。</td></tr><tr><td>/opt</td><td>这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果你想要自行安装额外的软件（非原本的distribution提供的），那么也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！</td></tr><tr><td>/run</td><td>早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 /var/run 目录下，新版的 FHS 则规范到 /run 下面。 由于 /run 可以使用内存来仿真，因此性能上会好很多！</td></tr><tr><td>/sbin</td><td>Linux有非常多指令是用来设置系统环境的，这些指令只有root才能够利用来“设置”系统，其他使用者最多只能用来“查询”而已。 放在/sbin下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统可执行文件（system binary）， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。</td></tr><tr><td>/srv</td><td>srv可以视为“service”的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。 不过，系统的服务数据如果尚未要提供给网际网络任何人浏览的话，默认还是建议放置到 /var/lib 下面即可。</td></tr><tr><td>/tmp</td><td>这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！</td></tr><tr><td>/usr</td><td>第二层 FHS 设置，后续介绍</td></tr><tr><td>/var</td><td>第二曾 FHS 设置，主要为放置变动性的数据，后续介绍</td></tr><tr><td>第二部份：FHS 建议可以存在的目录</td><td></td></tr><tr><td>/home</td><td>这是系统默认的使用者主文件夹（home directory）。在你新增一个一般使用者帐号时， 默认的使用者主文件夹都会规范到这里来。比较重要的是，主文件夹有两种代号喔：~：代表目前这个使用者的主文件夹 ~dmtsai ：则代表 dmtsai 的主文件夹！</td></tr><tr><td>/lib<qual></qual></td><td>用来存放与 /lib 不同的格式的二进制函数库，例如支持 64 位的 /lib64 函数库等</td></tr><tr><td>/root</td><td>系统管理员（root）的主文件夹。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的主文件夹，所以我们会希望root的主文件夹与根目录放置在同一个分区中。</td></tr></tbody></table></div><p>/usr 的意义与内容：</p><p>usr叫做Unix Software Resource Unix操作系统软件资源”所放置的目录。所有系统默认的软件（distribution发布者提供的软件）都会放置到/usr下面，因此这个目录有点类似Windows 系统的“C:\Windows\ （当中的一部份） + C:\Program files\”这两个目录的综合体</p><div class="table-container"><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td>第一部份：FHS 要求必须要存在的目录</td><td></td></tr><tr><td>/usr/bin/</td><td>所有一般用户能够使用的指令都放在这里！目前新的 CentOS 7 已经将全部的使用者指令放置于此，而使用链接文件的方式将 /bin 链接至此！ 也就是说， /usr/bin 与 /bin 是一模一样了！另外，FHS 要求在此目录下不应该有子目录！</td></tr><tr><td>/usr/lib/</td><td>基本上，与 /lib 功能相同，所以 /lib 就是链接到此目录中的！</td></tr><tr><td>/usr/local/</td><td>系统管理员在本机自行安装自己下载的软件（非distribution默认提供者），建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录喔！</td></tr><tr><td>/usr/sbin/</td><td>非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令（daemon）啰！不过基本功能与 /sbin 也差不多， 因此目前 /sbin 就是链接到此目录中的。</td></tr><tr><td>/usr/share/</td><td>主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文字文件嘛！在此目录下常见的还有这些次目录：/usr/share/man：线上说明文档 /usr/share/doc：软件杂项的文件说明 /usr/share/zoneinfo：与时区有关的时区文件</td></tr><tr><td>第二部份：FHS 建议可以存在的目录</td><td></td></tr><tr><td>/usr/games/</td><td>与游戏比较相关的数据放置处</td></tr><tr><td>/usr/include/</td><td>c/c++等程序语言的文件开始（header）与包含档（include）放置处，当我们以tarball方式 （*.tar.gz 的方式安装软件）安装某些数据时，会使用到里头的许多包含档喔！</td></tr><tr><td>/usr/libexec/</td><td>某些不被一般使用者惯用的可执行文件或脚本（script）等等，都会放置在此目录中。例如大部分的 X 窗口下面的操作指令， 很多都是放在此目录下的。</td></tr><tr><td>/usr/lib<qual>/</qual></td><td>与 /lib<qual>/功能相同，因此目前 /lib<qual> 就是链接到此目录中</qual></qual></td></tr><tr><td>/usr/src/</td><td>一般源代码建议放置到这里，src有source的意思。至于核心源代码则建议放置到/usr/src/linux/目录下。</td></tr></tbody></table></div><p>/var 的意义与内容：</p><p>如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运行后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括高速缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如MySQL数据库的文件等等。</p><div class="table-container"><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td>第一部份：FHS 要求必须要存在的目录</td><td></td></tr><tr><td>/var/cache/</td><td>应用程序本身运行过程中会产生的一些暂存盘；</td></tr><tr><td>/var/lib/</td><td>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！</td></tr><tr><td>/var/lock/</td><td>某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时， 就可能产生一些错误的状况，因此就得要将该设备上锁（lock），以确保该设备只会给单一软件所使用。 举例来说，烧录机正在烧录一块光盘，你想一下，会不会有两个人同时在使用一个烧录机烧片？ 如果两个人同时烧录，那片子写入的是谁的数据？所以当第一个人在烧录时该烧录机就会被上锁， 第二个人就得要该设备被解除锁定（就是前一个人用完了）才能够继续使用啰。目前此目录也已经挪到 /run/lock 中！</td></tr><tr><td>/var/log/</td><td>重要到不行！这是登录文件放置的目录！里面比较重要的文件如/var/log/messages, /var/log/wtmp（记录登陆者的信息）等。</td></tr><tr><td>/var/mail/</td><td>放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！ 通常这两个目录是互为链接文件啦！</td></tr><tr><td>/var/run/</td><td>某些程序或者是服务启动后，会将他们的PID放置在这个目录下喔！至于PID的意义我们会在后续章节提到的。 与 /run 相同，这个目录链接到 /run 去了！</td></tr><tr><td>/var/spool/</td><td>这个目录通常放置一些伫列数据，所谓的“伫列”就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作调度数据（crontab），就会被放置到/var/spool/cron/目录中！</td></tr></tbody></table></div><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="执行文件路径的变量：-PATH"><a href="#执行文件路径的变量：-PATH" class="headerlink" title="执行文件路径的变量： $PATH"></a>执行文件路径的变量： $PATH</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span> <span class="comment"># echo有“显示、印出”的意思</span></span><br></pre></td></tr></table></figure><p>搜索过程</p><p>系统会依照PATH的设置去每个PATH定义的目录下搜寻文件名为ls的可可执行文件， 如果在PATH定义的目录中含有多个文件名为ls的可可执行文件，那么先搜寻到的同名指令先被执行！</p><p>新增PATH（<strong>仅仅在本次登录shell有效,也就是说重启后就会还原</strong> ）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PATH</span>=<span class="string">"$&#123;PATH&#125;:/root"</span></span><br></pre></td></tr></table></figure><h3 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h3><p><strong>ls</strong></p><p>常用选项参数</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-a  ：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）</span></span><br><span class="line"><span class="deletion">-l  ：长数据，包含文件的属性与权限等等数据；（常用）</span></span><br></pre></td></tr></table></figure><p><strong>cp, rm, mv</strong></p><p>cp常用选项参数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="selector-tag">a</span>  ：除了 -<span class="selector-tag">p</span> 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制  了。（常用）</span><br><span class="line">-s  ：复制成为符号链接文件 （symbolic link），亦即“捷径”文件；</span><br><span class="line">-l  ：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；</span><br><span class="line">-<span class="selector-tag">i</span>  ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）</span><br><span class="line">-r  ：递回持续复制，用于目录的复制行为；（常用）</span><br><span class="line">-<span class="selector-tag">p</span>  ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）</span><br></pre></td></tr></table></figure><ul><li>cp的文件必须有read 的权限</li><li><strong>cp 的来源文件与目的文件的权限是不同的</strong>，目的文件的拥有者通常会是指令操作者本身。另外，如果你想要复制文件给其他的使用者， 也必须要注意到文件的权限（包含读、写、执行以及文件拥有者等等）</li></ul><p>由于 cp 有种种的文件属性与权限的特性，所以，在复制时，你必须要清楚的了解到：</p><ul><li>是否需要完整的保留来源文件的信息？</li><li>来源文件是否为链接文件 （symbolic link file）？</li><li>来源文件是否为特殊的文件，例如 FIFO, socket 等？</li><li>来源文件是否为目录？</li></ul><p>rm</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># rm [-fir] 文件或目录</span></span><br><span class="line">选项与参数：</span><br><span class="line"><span class="literal">-f  ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；</span></span><br><span class="line"><span class="literal">-i  ：互动模式，在删除前会询问使用者是否动作</span></span><br><span class="line"><span class="literal">-r  ：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！</span></span><br></pre></td></tr></table></figure><p>mv</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># mv [-fiu] source destination</span></span><br><span class="line">[root@study ~]<span class="comment"># mv [options] source1 source2 source3 .... directory</span></span><br><span class="line">选项与参数：</span><br><span class="line"><span class="literal">-f  ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</span></span><br><span class="line"><span class="literal">-i  ：若目标文件 （destination） 已经存在时，就会询问是否覆盖！</span></span><br><span class="line"><span class="literal">-u  ：若目标文件已经存在，且 source 比较新，才会更新 （update）</span></span><br></pre></td></tr></table></figure><p>注意到这边，如果有多个来源文件或目录，则最后一个目标文件一定是“目录！”</p><h3 id="文件内容查阅与创建"><a href="#文件内容查阅与创建" class="headerlink" title="文件内容查阅与创建"></a>文件内容查阅与创建</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文件</span></span><br><span class="line">less /etc/man_db.conf<span class="comment"># 读取文件内容，其编辑器选项如下所示</span></span><br><span class="line"><span class="comment"># 摘取文件读取</span></span><br><span class="line"> head [-n <span class="built_in">number</span>] 文件</span><br><span class="line"> tail [-n <span class="built_in">number</span>] 文件</span><br></pre></td></tr></table></figure><p>每个文件有三个时间</p><ul><li><strong>modification time （mtime）</strong>： 当该文件的“内容数据”变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！</li><li><strong>status time （ctime）</strong>： 当该文件的“状态 （status）”改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。</li><li><strong>access time （atime）</strong>： 当“该文件的内容被取用”时，就会更新这个读取时间 （access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ll </span>--time=atime <span class="keyword">bashrc </span> <span class="comment"># 这样来实现</span></span><br></pre></td></tr></table></figure><p>touch</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">touch [-acdm] 文件</span><br><span class="line">-<span class="ruby">a  ：仅修订 access time；</span></span><br><span class="line"><span class="ruby">-c  ：仅修改文件的时间，若该文件不存在则不创建新文件；</span></span><br><span class="line"><span class="ruby">-d  ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date=<span class="string">"日期或时间"</span></span></span><br><span class="line"><span class="ruby">-m  ：仅修改 mtime ；</span></span><br></pre></td></tr></table></figure><ul><li>创建一个空的文件；</li><li>将某个文件日期修订为目前 （mtime 与 atime）</li></ul><h3 id="文件默认权限"><a href="#文件默认权限" class="headerlink" title="文件默认权限"></a>文件默认权限</h3><ul><li>若使用者创建为“文件”则默认“没有可执行（ x ）权限”，亦即只有 rw 这两个项目，也就是最大为 666 分，默认权限如下： -rw-rw-rw-</li><li>若使用者创建为“目录”，则由于 x 与是否可以进入此目录有关，因此默认为所有权限均开放，亦即为 777 分，默认权限如下： drwxrwxrwx</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">umask</span></span><br><span class="line"><span class="number">0022</span>             &amp;<span class="keyword">lt</span>;==与一般权限有关的是后面三个数字！</span><br></pre></td></tr></table></figure><p>umask 的分数指的是“该默认值需要减掉的权限！”因为 r、w、x 分别是 4、2、1 分</p><p>如果以上面的例子来说明的话，因为 umask 为 022 ，所以 user 并没有被拿掉任何权限，不过 group 与 others 的权限被拿掉了 2 （也就是 w 这个权限），那么当使用者：</p><ul><li>创建文件时：（-rw-rw-rw-） - （——-w—w-） ==&gt; -rw-r—r—</li><li>创建目录时：（drwxrwxrwx） - （d——w—w-） ==&gt; drwxr-xr-x</li></ul><p><strong>文件隐藏属性</strong></p><p>设置</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> chattr [<span class="string">+-=</span>][<span class="symbol">ASacdistu</span>] 文件或目录名称</span><br><span class="line">选项与参数：</span><br><span class="line"><span class="bullet">+   </span>：增加某一个特殊参数，其他原本存在参数则不动。</span><br><span class="line"><span class="bullet">-   </span>：移除某一个特殊参数，其他原本存在参数则不动。</span><br><span class="line">=   ：设置一定，且仅有后面接的参数</span><br><span class="line">A  ：当设置了 A 这个属性时，若你有存取此文件（或目录）时，他的存取时间 atime 将不会被修改，</span><br><span class="line"><span class="code">     可避免 I/O 较慢的机器过度的存取磁盘。（目前建议使用文件系统挂载参数处理这个项目）</span></span><br><span class="line">i  ：这个 i 可就很厉害了！他可以让一个文件“不能被删除、改名、设置链接也无法写入或新增数据！”</span><br><span class="line"><span class="code">     对于系统安全性有相当大的助益！只有 root 能设置此属性</span></span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># lsattr [-adR] 文件或目录</span></span><br><span class="line">选项与参数：</span><br><span class="line"><span class="literal">-a ：将隐藏文件的属性也秀出来；</span></span><br><span class="line"><span class="literal">-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；</span></span><br><span class="line"><span class="literal">-R ：连同子目录的数据也一并列出来！</span></span><br><span class="line"></span><br><span class="line">[root@study tmp]<span class="comment"># chattr +aiS attrtest</span></span><br><span class="line">[root@study tmp]<span class="comment"># lsattr attrtest</span></span><br><span class="line"><span class="literal">--S-ia---------- attrtest</span></span><br></pre></td></tr></table></figure><p><strong>特殊权限</strong></p><p>前提：进程有属主和属组；文件有属主和属组；</p><p>(1) 任何一个可执行程序文件能不能启动为进程：取决于发起者对程序文件是否拥有执行权限；</p><p>(2) 启动为进程之后，其进程的属主为发起者；进程的属组为发起者所属的组；</p><p>(3) 进程访问文件时的权限，取决于进程的发起者：</p><p>​    (a) 进程的发起者，同文件的属主：则应用文件属主权限；</p><p>​    (b) 进程的发起者，属于文件的属组；则应用文件属组权限；</p><p>​    (c) 应用文件“其它”权限；</p><p><strong>SUID</strong></p><ol><li>启动为进程之后，其进程的属主为原程序文件的属主；</li><li>只能作用在二进制程序上,不能作用在脚本上,且设置在目录上无意义 ;</li><li>执行suid权限的程序时,此用户将继承此程序的所有者权限;  </li><li>本权限仅在执行该程序的过程中有效 （run-time）；</li><li>所有者必须对欲设置SetUID的文件具备 <strong>可执行(x)</strong> 权限</li></ol><p>也就是说该命令具有了root权限，可以通过改命令执行其他命令。</p><p><strong>SGID </strong></p><p>针对文件或目录来设置</p><p>1.作用于文件：执行sgid权限的程序时,此用户将继承此程序的所属组权限。</p><p>2.作用于文件夹：此文件夹下所有用户新建文件都自动继承此目录的用户组。</p><p><strong>SBIT</strong></p><p>1.只对目录有效</p><p>2.普通用户对该目录有<code>w</code>和<code>x</code>权限</p><p>3.若没有粘滞位，则普通用户可以对目录下的文件/子目录进行删除操作（因为普通用户对目录具有<code>w</code>权限），包括其它用户建立的目录/文件；但若赋了SBIT,则普通用户只能删除自己创建的文件/目录，而不能删除不属于自己的文件/目录！</p><ul><li>4 为 SUID</li><li>2 为 SGID</li><li>1 为 SBIT</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# <span class="keyword">cd</span> /tmp</span><br><span class="line">[root@study tmp]# touch <span class="keyword">test</span>                  &amp;lt;==创建一个测试用空档</span><br><span class="line">[root@study tmp]# chmod 4755 <span class="keyword">test</span>; <span class="keyword">ls</span> -<span class="keyword">l</span> <span class="keyword">test</span> &amp;lt;==加入具有 SUID 的权限</span><br><span class="line">-rwsr-xr-x 1 root root 0 Jun 16 02:53 <span class="keyword">test</span></span><br><span class="line">[root@study tmp]# chmod 6755 <span class="keyword">test</span>; <span class="keyword">ls</span> -<span class="keyword">l</span> <span class="keyword">test</span> &amp;lt;==加入具有 SUID/SGID 的权限</span><br><span class="line">-rwsr-sr-x 1 root root 0 Jun 16 02:53 <span class="keyword">test</span></span><br><span class="line">[root@study tmp]# chmod 1755 <span class="keyword">test</span>; <span class="keyword">ls</span> -<span class="keyword">l</span> <span class="keyword">test</span> &amp;lt;==加入 SBIT 的功能！</span><br><span class="line">-rwxr-xr-t 1 root root 0 Jun 16 02:53 <span class="keyword">test</span></span><br><span class="line">[root@study tmp]# chmod 7666 <span class="keyword">test</span>; <span class="keyword">ls</span> -<span class="keyword">l</span> <span class="keyword">test</span> &amp;lt;==具有空的 SUID/SGID 权限</span><br><span class="line">-rwSrwSrwT 1 root root 0 Jun 16 02:53 <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p>最后一个例子就要特别小心啦！怎么会出现大写的 S 与 T 呢？不都是小写的吗？ 因为 s 与 t 都是取代 x 这个权限的，但是你有没有发现阿，我们是下达 7666 喔！也就是说， user, group 以及 others 都没有 x 这个可执行的标志（ 因为 666 嘛 ），所以，这个 S, T 代表的就是“空的”啦！怎么说？ SUID 是表示“该文件在执行的时候，具有文件拥有者的权限”，但是文件 拥有者都无法执行了，哪里来的权限给其他人使用？当然就是空的啦！ ^_^</p><h3 id="指令与文件的搜寻"><a href="#指令与文件的搜寻" class="headerlink" title="指令与文件的搜寻"></a>指令与文件的搜寻</h3><h4 id="命令的搜索"><a href="#命令的搜索" class="headerlink" title="命令的搜索"></a>命令的搜索</h4><p>which （寻找“可执行文件”）寻找的是命令所在的文件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># which [-a] command</span></span><br><span class="line">选项或参数：</span><br><span class="line">-a ：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称</span><br></pre></td></tr></table></figure><h4 id="文件文件名的搜寻"><a href="#文件文件名的搜寻" class="headerlink" title="文件文件名的搜寻"></a>文件文件名的搜寻</h4><p>通常 find 不很常用的！因为速度慢之外， 也很操硬盘！一般我们都是先使用 whereis 或者是 locate 来检查，如果真的找不到了，才以 find 来搜寻。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">whereis</span> 文件或目录名</span><br><span class="line">＃　只在几个特定的目录下找</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">locate [-ir] keyword</span><br><span class="line"><span class="deletion">-i  ：忽略大小写的差异；</span></span><br><span class="line"><span class="deletion">-r  ：后面可接正则表达式的显示方式</span></span><br></pre></td></tr></table></figure><p>locate 寻找的数据是由“已创建的数据库 /var/lib/mlocate/” 里面的数据所搜寻到的，所以要更新数据库否则有可能新建的找不到。</p><ul><li>updatedb：根据 /etc/updatedb.conf 的设置去搜寻系统硬盘内的文件名，并更新 /var/lib/mlocate 内的数据库文件；</li><li>locate：依据 /var/lib/mlocate 内的数据库记载，找出使用者输入的关键字文件名。</li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@study ~]</span># find <span class="string">[PATH]</span> <span class="string">[option]</span> <span class="string">[action]</span></span><br></pre></td></tr></table></figure><p>有可能你需要看某个用户创建了啥咚咚</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2\. 与使用者或群组名称有关的参数：</span><br><span class="line">   -uid n ：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在</span><br><span class="line">            /etc/passwd 里面与帐号名称对应的数字。这方面我们会在第四篇介绍。</span><br><span class="line">   -gid n ：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在</span><br><span class="line">            /etc/group，相关的介绍我们会第四篇说明～</span><br><span class="line">   -user name ：name 为使用者帐号名称喔！例如 dmtsai </span><br><span class="line">   -group name：name 为群组名称喔，例如<span class="built_in"> users </span>；</span><br><span class="line">   -nouser    ：寻找文件的拥有者不存在 /etc/passwd 的人！</span><br><span class="line">   -nogroup   ：寻找文件的拥有群组不存在于 /etc<span class="built_in">/group </span>的文件！</span><br><span class="line">                当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，</span><br><span class="line">                这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">3\. 与文件权限及名称有关的参数：</span><br><span class="line">   -name filename：搜寻文件名称为 filename 的文件；</span><br><span class="line">   -size [+-]SIZE：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有：</span><br><span class="line">                   c: 代表 Byte， k: 代表 1024Bytes。所以，要找比 50KB</span><br><span class="line">                   还要大的文件，就是“ -size +50k ”</span><br><span class="line">   -type<span class="built_in"> TYPE </span>   ：搜寻文件的类型为<span class="built_in"> TYPE </span>的，类型主要有：一般正规文件 （f）, 设备文件 （b, c）,</span><br><span class="line">                   目录 （d）, 链接文件 （l）, socket （s）, 及 FIFO （p） 等属性。</span><br><span class="line">   -perm mode  ：搜寻文件权限“刚好等于” mode 的文件，这个 mode 为类似 chmod</span><br><span class="line">                 的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！</span><br><span class="line">   -perm -mode ：搜寻文件权限“必须要全部囊括 mode 的权限”的文件，举例来说，</span><br><span class="line">                 我们要搜寻 -rwxr--r-- ，亦即 0744 的文件，使用 -perm -0744，</span><br><span class="line">                 当一个文件的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来，</span><br><span class="line">                 因为 -rwsr-xr-x 的属性已经囊括了 -rwxr--r-- 的属性了。</span><br><span class="line">   -perm /mode ：搜寻文件权限“包含任一 mode 的权限”的文件，举例来说，我们搜寻</span><br><span class="line">                 -rwxr-xr-x ，亦即 -perm /755 时，但一个文件属性为 -rw-------</span><br><span class="line">                 也会被列出来，因为他有 -rw<span class="built_in">..</span><span class="built_in">..</span> 的属性存在！</span><br><span class="line">                 </span><br><span class="line">范例五：找出文件名为 passwd 这个文件</span><br><span class="line">[root@study ~]# <span class="builtin-name">find</span> / -name passwd</span><br><span class="line"></span><br><span class="line">范例五-1：找出文件名包含了 passwd 这个关键字的文件</span><br><span class="line">[root@study ~]# <span class="builtin-name">find</span> / -name <span class="string">"*passwd*"</span></span><br><span class="line"><span class="comment"># 利用这个 -name 可以搜寻文件名啊！默认是完整文件名，如果想要找关键字，</span></span><br><span class="line"><span class="comment"># 可以使用类似 * 的任意字符来处理</span></span><br><span class="line"></span><br><span class="line">范例六：找出 /<span class="builtin-name">run</span> 目录下，文件类型为 Socket 的文件名有哪些？</span><br><span class="line">[root@study ~]# <span class="builtin-name">find</span> /<span class="builtin-name">run</span> -type s</span><br><span class="line"><span class="comment"># 这个 -type 的属性也很有帮助喔！尤其是要找出那些怪异的文件，</span></span><br><span class="line"><span class="comment"># 例如 socket 与 FIFO 文件，可以用 find /run -type p 或 -type s 来找！</span></span><br><span class="line"></span><br><span class="line">范例七：搜寻文件当中含有 SGID 或 SUID 或 SBIT 的属性</span><br><span class="line">[root@study ~]# <span class="builtin-name">find</span> / -perm /7000 </span><br><span class="line"><span class="comment"># 所谓的 7000 就是 ---s--s--t ，那么只要含有 s 或 t 的就列出，所以当然要使用 /7000，</span></span><br><span class="line"><span class="comment"># 使用 -7000 表示要同时含有 ---s--s--t 的所有三个权限。而只需要任意一个，就是 /7000 ～瞭乎？</span></span><br></pre></td></tr></table></figure><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line"><span class="number">4</span>\. 额外可进行的动作：</span><br><span class="line">   -<span class="keyword">exec</span> command ：command 为其他指令，-<span class="keyword">exec</span> 后面可再接额外的指令来处理搜寻到的结果。</span><br><span class="line">   -<span class="keyword">print</span>        ：将结果打印到屏幕上，这个动作是默认动作！</span><br><span class="line"></span><br><span class="line">范例八：将上个范例找到的文件使用 <span class="keyword">ls</span> -l 列出来～</span><br><span class="line">[root@study ~]# find /usr/bin /usr/sbin -perm /<span class="number">7000</span> -<span class="keyword">exec</span> <span class="keyword">ls</span> -l &#123;&#125; \;</span><br><span class="line"># 注意到，那个 -<span class="keyword">exec</span> 后面的 <span class="keyword">ls</span> -l 就是额外的指令，指令不支持命令别名，</span><br><span class="line"># 所以仅能使用 <span class="keyword">ls</span> -l 不可以使用 ll 喔！注意注意！</span><br></pre></td></tr></table></figure><ul><li>{} 代表的是“由 find 找到的内容”，如上图所示，find 的结果会被放置到 {} 位置中；</li><li>-exec 一直到 \; 是关键字，代表 find 额外动作的开始 （-exec） 到结束 （\;） ，在这中间的就是 find 指令内的额外动作。 在本例中就是“ ls -l {} ”啰！</li><li>因为“ ; ”在 bash 环境下是有特殊意义的，因此利用反斜线来跳脱。</li></ul><h2 id="第七章-文件系统"><a href="#第七章-文件系统" class="headerlink" title="第七章 文件系统"></a>第七章 文件系统</h2><p>文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中。</p><p> 另外，还有一个超级区块 （superblock） 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。</p><ul><li>superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；</li><li>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码；</li><li>block：实际记录文件的内容，若文件太大时，会占用多个 block 。</li></ul><p>EX2 系统</p><p><strong>block</strong></p><ul><li>原则上，block 的大小与数量在格式化完就不能够再改变了（除非重新格式化）；</li><li>每个 block 内最多只能够放置一个文件的数据；</li><li>承上，如果文件大于 block 的大小，则一个文件会占用多个 block 数量；</li><li>承上，若文件小于 block ，则该 block 的剩余容量就不能够再被使用了（磁盘空间会浪费）</li></ul><p>过大的block会浪费空间，过小的block会导致占据过多block，读写性能降低。</p><p><strong>inode</strong></p><p>inode 的数量与大小也是在格式化时就已经固定了</p><ul><li>每个 inode 大小均固定为 128 Bytes （新的 ext4 与 xfs 可设置到 256 Bytes）；</li><li>每个文件都仅会占用一个 inode 而已；</li><li>承上，因此文件系统能够创建的文件数量与 inode 的数量有关，大小与inode的大小有关；</li><li>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与使用者是否符合，若符合才能够开始实际读取 block 的内容。</li></ul><p><strong>第一层inode12个是固定的，没得算，后面的才可以算</strong></p><p>inode一般为128字节或256字节<br>每个inode中都记录着文件所在的block号,每条记录着block号的信息占用4字节。<br>inode中关于block号的记录一共包含12个直接,1个间接,1个双间接和1个三间接<br>12个直接连接：共占用48字节磁盘空间,包含着12个直接指向block号的信息，若此文件系统默认的block大小为4kb,则仅仅可以指向12*4=48kb大小的文件内容,然而我们的文件若较大时,则需要使用到更多的block,肯定要多于12个block,进而有间接,双间接和三间接</p><p>间接：inode中所记录这4字节的内容,所指向一个block,这个block中存放的不是真的文件内容,而是真实文件所存放位置的block号信息,若每个block大小为4kb,那么可以存放1024个block号信息1个间接可以存放的文件大小为1024*4=4096kb</p><p>双间接：在间接的基础上在进行间接,若默认的block仍然为4kb,那么1个双间接可以存放文件内容的大小为1024<em>1024</em>4=4096MB</p><p>三间接：在双间接的基础上再进行间接,若默认的block仍然为4kb,那么1个双间接可以存放文件内容的大小为1024<em>1024</em>1024*4=4096GB也就是说在一个block大小默认为4KB的文件系统中,一个文件最大存储可达48kb+4096kb+4096MB+4096GB=4100GB</p><p><strong>Superblock</strong></p><p>uperblock 是记录整个 filesystem 相关信息的地方， 没有 Superblock ，就没有这个 filesystem 了。他记录的信息主要有：</p><ul><li>block 与 inode 的总量；</li><li>未使用与已使用的 inode / block 数量；</li><li>block 与 inode 的大小 （block 为 1, 2, 4K，inode 为 128Bytes 或 256Bytes）；</li><li>filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 （fsck） 的时间等文件系统的相关信息；</li><li>一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1 。</li></ul><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># dumpe2fs [-bh] 设备文件名</span></span><br><span class="line">选项与参数：</span><br><span class="line"><span class="literal">-b ：列出保留为坏轨的部分（一般用不到吧！？）</span></span><br><span class="line"><span class="literal">-h ：仅列出 superblock 的数据，不会列出其他的区段内容！</span></span><br></pre></td></tr></table></figure><p><strong>与目录树的关系</strong></p><p>每个文件（不管是一般文件还是目录文件）都会占用一个 inode ， 且可依据文件内容的大小来分配多个 block 给该文件使用</p><p><strong>注意随着block的增多，inode也需要增多，初始innode只有12个直接指向</strong></p><ul><li>目录</li></ul><p>当我们在 Linux 下的文件系统创建一个目录时，文件系统会分配一个 inode 与至少一块 block 给该目录。其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块 block 号码； 而 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。</p><p>为什么文件大小几乎都是1024的倍数，因为每个block都是1K/2K/4K</p><ul><li>文件</li></ul><p>例如：假设我的一个 block 为 4 KBytes ，而我要创建一个 100 KBytes 的文件，那么 linux 将分配一个 inode 与 25 个 block 来储存该文件！ 但同时请注意，由于 inode 仅有 12 个直接指向，因此还要多一个 block 来作为区块号码的记录喔！</p><ul><li>目录树读取</li></ul><p>读取 /etc/passwd 文件流程：</p><ol><li>/ 的 inode： 通过挂载点的信息找到 inode 号码为 128 的根目录 inode，且 inode 规范的权限让我们可以读取该 block 的内容（有 r 与 x） ；</li><li>/ 的 block： 经过上个步骤取得 block 的号码，并找到该内容有 etc/ 目录的 inode 号码 （33595521）；</li><li>etc/ 的 inode： 读取 33595521 号 inode 得知 dmtsai 具有 r 与 x 的权限，因此可以读取 etc/ 的 block 内容；</li><li>etc/ 的 block： 经过上个步骤取得 block 号码，并找到该内容有 passwd 文件的 inode 号码 （36628004）；</li><li>passwd 的 inode： 读取 36628004 号 inode 得知 dmtsai 具有 r 的权限，因此可以读取 passwd 的 block 内容；</li><li>passwd 的 block： 最后将该 block 内容的数据读出来。</li><li>filesystem 大小与磁盘读取性能：</li></ol><p>新增文件流程：</p><ol><li>先确定使用者对于欲新增文件的目录是否具有 w 与 x 的权限，若有的话才能新增；</li><li>根据 inode bitmap 找到没有使用的 inode 号码，并将新文件的权限/属性写入；</li><li>根据 block bitmap 找到没有使用中的 block 号码，并将实际的数据写入 block 中，且更新 inode 的 block 指向数据；</li><li>将刚刚写入的 inode 与 block 数据同步更新 inode bitmap 与 block bitmap，并更新 superblock 的内容。</li></ol><p><strong>日志式文件系统</strong></p><p>避免由于某些不可抗因素，没有写完数据导致的数据不一致</p><ol><li>预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息；</li><li>实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据；</li><li>结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。</li></ol><p>每个 filesystem 都有独立的 inode / block / superblock 等信息，这个文件系统要能够链接到目录树才能被我们使用。 将文件系统与目录树结合的动作我们称为“挂载”。<strong>挂载点一定是目录</strong></p><h4 id="文件系统操作"><a href="#文件系统操作" class="headerlink" title="文件系统操作"></a>文件系统操作</h4><p><strong>查看文件系统大小</strong></p><p>df 主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要是在 Superblock 内的信息</p><p>du 直接到文件系统内去搜寻所有的文件数据</p><p>du == disk usage (磁盘使用量，占用的磁盘空间),ls -h看的是文件大小，文件大小和文件所占磁盘量是不一样的。</p><p><strong>实体链接与符号链接</strong></p><ul><li>hard link</li></ul><p>1.hard link 只是在某个目录下新增一笔文件名链接到某 inode 号码的关连记录而已。</p><p>2.使用 hard link 设置链接文件时，磁盘的空间与 inode 的数目都不会改变，引用计数会变！</p><p>3.hard link 只是在某个目录下的 block 多写入一个关连数据而已，既不会增加 inode 也不会耗用 block 数量</p><p>相当于一间教室开多扇门</p><p>限制</p><ul><li>不能跨 Filesystem；（保持原Inode）</li><li>不能 link 目录。（避免对目录下文件递归链接）</li></ul><ul><li><p>符号链接</p><p>Symbolic link 就是在创建一个独立的文件，而这个文件会让数据的读取指向他 link 的那个文件的文件名。</p></li></ul><p>它是创建了独立的indoe，然后在block再放原文件的i节点号</p><p>1.会占用掉自己的inode与block</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># ln [-sf] 来源文件 目标文件</span></span><br><span class="line">选项与参数：</span><br><span class="line">-<span class="keyword">s</span>  ：如果不加任何参数就进行链接，那就是hard <span class="keyword">link</span>，至于 -<span class="keyword">s</span> 就是symbolic <span class="keyword">link</span></span><br><span class="line">-f  ：如果 目标文件 存在时，就主动的将目标文件直接移除后再创建！</span><br></pre></td></tr></table></figure><p>区别：</p><p>1.实体链接是记录Inode,有自己的限制，常用于作备份</p><p>2.符号链接是记录文件名，类似快捷方式，无限制</p><h4 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h4><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># lsblk [-dfimpt] [device]</span></span><br><span class="line">选项与参数：</span><br><span class="line"><span class="literal">-d  ：仅列出磁盘本身，并不会列出该磁盘的分区数据</span></span><br><span class="line"><span class="literal">-f  ：同时列出该磁盘内的文件系统名称</span></span><br><span class="line"><span class="literal">-i  ：使用 ASCII 的线段输出，不要使用复杂的编码 （再某些环境下很有用）</span></span><br><span class="line"><span class="literal">-m  ：同时输出该设备在 /dev 下面的权限数据 （rwx 的数据）</span></span><br><span class="line"><span class="literal">-p  ：列出该设备的完整文件名！而不是仅列出最后的名字而已。</span></span><br><span class="line"><span class="literal">-t  ：列出该磁盘设备的详细数据，包括磁盘伫列机制、预读写的数据量大小等</span></span><br></pre></td></tr></table></figure><p>还有磁盘的分区和挂载我觉得不太重要</p><p><strong>SWAP分区</strong></p><p> 那当内存不足的时候，为了让后续的程序可以顺利的运行，因此在内存中暂不使用的程序与数据就会被挪到 swap 中了。 此时内存就会空出来给需要执行的程序载入。由于 swap 是用磁盘来暂时放置内存中的信息。</p><h3 id="第八章-压缩文件系统"><a href="#第八章-压缩文件系统" class="headerlink" title="第八章 压缩文件系统"></a>第八章 压缩文件系统</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-class">.Z</span>         compress 程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.zip</span>       zip 程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.gz</span>        gzip 程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.bz2</span>       bzip2 程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.xz</span>        xz 程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.tar</span>       tar 程序打包的数据，并没有压缩过；</span><br><span class="line">*<span class="selector-class">.tar</span><span class="selector-class">.gz</span>    tar 程序打包的文件，其中并且经过 gzip 的压缩</span><br><span class="line">*<span class="selector-class">.tar</span><span class="selector-class">.bz2</span>   tar 程序打包的文件，其中并且经过 bzip2 的压缩</span><br><span class="line">*<span class="selector-class">.tar</span><span class="selector-class">.xz</span>    tar 程序打包的文件，其中并且经过 xz 的压缩</span><br></pre></td></tr></table></figure><p> gzip, bzip2,xz :仅能针对一个文件来压缩与解压缩</p><p> tar:一开始仅是“打包”而已，亦即是将很多文件集结成为一个文件，后来提供了压缩的功能</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>gzip [-cdtv<span class="comment">#] 文件名</span></span><br><span class="line">选项与参数：</span><br><span class="line">-c  ：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；</span><br><span class="line">-d  ：解压缩的参数；</span><br></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>bzip2 [-cdkzv<span class="comment">#] 文件名</span></span><br><span class="line">选项与参数：</span><br><span class="line">-c  ：将压缩的过程产生的数据输出到屏幕上！</span><br><span class="line">-d  ：解压缩的参数</span><br></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>xz [-dtlkc<span class="comment">#] 文件名</span></span><br><span class="line">选项与参数：</span><br><span class="line">-c  ：将压缩的过程产生的数据输出到屏幕上！</span><br><span class="line">-d  ：解压缩的参数</span><br></pre></td></tr></table></figure><p>压缩比：gzip&lt;bz&lt;xz</p><p>速度：gzip&gt;bz&gt;xz</p><h4 id="tar-打包"><a href="#tar-打包" class="headerlink" title="tar 打包"></a>tar 打包</h4><p>tar 可以将多个目录或文件打包成一个大文件，同时还可以通过 gzip/bzip2/xz 的支持，将该文件同时进行压缩</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ tar [-z&amp;<span class="comment">#124;-j&amp;#124;-J] [cv] [-f 待创建的新文件名] filename... &amp;lt;==打包与压缩</span></span><br><span class="line">[dmtsai@study ~]$ tar [-z&amp;<span class="comment">#124;-j&amp;#124;-J] [tv] [-f 既有的 tar文件名]             &amp;lt;==察看文件名</span></span><br><span class="line">[dmtsai@study ~]$ tar [-z&amp;<span class="comment">#124;-j&amp;#124;-J] [xv] [-f 既有的 tar文件名] [-C 目录]   &amp;lt;==解压缩</span></span><br><span class="line">选项与参数：</span><br><span class="line"><span class="literal">-c  ：创建打包文件，可搭配 -v 来察看过程中被打包的文件名（filename）</span></span><br><span class="line"><span class="literal">-t  ：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了；</span></span><br><span class="line"><span class="literal">-x  ：解打包或解压缩的功能，可以搭配 -C （大写） 在特定目录解开</span></span><br><span class="line">      特别留意的是， -c, -t, -x 不可同时出现在一串命令行中。</span><br><span class="line"><span class="literal">-z  ：通过 gzip  的支持进行压缩/解压缩：此时文件名最好为 *.tar.gz</span></span><br><span class="line"><span class="literal">-j  ：通过 bzip2 的支持进行压缩/解压缩：此时文件名最好为 *.tar.bz2</span></span><br><span class="line"><span class="literal">-J  ：通过 xz    的支持进行压缩/解压缩：此时文件名最好为 *.tar.xz</span></span><br><span class="line">      特别留意， -z, -j, -J 不可以同时出现在一串命令行中</span><br><span class="line"><span class="literal">-v  ：在压缩/解压缩的过程中，将正在处理的文件名显示出来！</span></span><br><span class="line"><span class="literal">-f filename：-f 后面要立刻接要被处理的文件名！建议 -f 单独写一个选项啰！（比较不会忘记）</span></span><br><span class="line"><span class="literal">-C 目录    ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</span></span><br><span class="line"></span><br><span class="line">其他后续练习会使用到的选项介绍：</span><br><span class="line"><span class="literal">-p（小写） ：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件</span></span><br><span class="line"><span class="literal">-P（大写） ：保留绝对路径，亦即允许备份数据中含有根目录存在之意；</span></span><br><span class="line"><span class="literal">--exclude=FILE：在压缩的过程中，不要将 FILE 打包！</span></span><br><span class="line"><span class="literal">--newer-mtime/ctime/atime：可以进行差异性备份，某个时间点前备过的份可以不用再备份。</span></span><br></pre></td></tr></table></figure><ul><li>压　缩：tar -j<u>c</u>v -f filename.tar.bz2 要被压缩的文件或目录名称</li><li>查　询：tar -j<u>t</u>v -f filename.tar.bz2</li><li>解压缩：tar -j<u>x</u>v -f filename.tar.bz2 -C 欲解压缩的目录</li></ul><p>z==gz</p><p>j==bz2</p><p>J==xz</p><h4 id="文件系统备份"><a href="#文件系统备份" class="headerlink" title="文件系统备份"></a>文件系统备份</h4><p>整个磁盘打包备份</p><h3 id="第九章-Vim编辑器"><a href="#第九章-Vim编辑器" class="headerlink" title="第九章 Vim编辑器"></a>第九章 Vim编辑器</h3><h4 id="Vi编辑器"><a href="#Vi编辑器" class="headerlink" title="Vi编辑器"></a>Vi编辑器</h4><ul><li>一般指令模式 （command mode）</li><li>编辑模式 （insert mode）</li><li>命令行命令模式 （command-line mode）</li></ul><p><img src="/2019/05/16/项目管理/鸟叔/E:/bolg/source/_posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Linux/3" alt="1560760769063"></p><ul><li>[O]pen Read-Only：打开此文件成为只读文件， 可以用在你只是想要查阅该文件内容并不想要进行编辑行为时。一般来说，在上课时，如果你是登陆到同学的计算机去看他的配置文件， 结果发现其实同学他自己也在编辑时，可以使用这个模式；</li><li>（E）dit anyway：还是用正常的方式打开你要编辑的那个文件， 并不会载入暂存盘的内容。不过很容易出现两个使用者互相改变对方的文件等问题！不好不好！</li><li>（R）ecover：就是载入暂存盘的内容，用在你要救回之前未储存的工作。 不过当你救回来并且储存离开 vim 后，还是要手动自行删除那个暂存盘喔！</li><li>（D）elete it：你确定那个暂存盘是无用的！那么打开文件前会先将这个暂存盘删除！ 这个动作其实是比较常做的！因为你可能不确定这个暂存盘是怎么来的，所以就删除掉他吧！哈哈！</li><li>（Q）uit：按下 q 就离开 vim ，不会进行任何动作回到命令提示字符。</li><li>（A）bort：忽略这个编辑行为，感觉上与 quit 非常类似！ 也会送你回到命令提示字符就是啰！</li></ul><h4 id="VIM编辑器"><a href="#VIM编辑器" class="headerlink" title="VIM编辑器"></a>VIM编辑器</h4><p><strong>特殊区域选择</strong></p><div class="table-container"><table><thead><tr><th>区块选择的按键意义</th><th></th></tr></thead><tbody><tr><td>v</td><td>字符选择，会将光标经过的地方反白选择！</td></tr><tr><td>V</td><td>列选择，会将光标经过的列反白选择！</td></tr><tr><td>[Ctrl]+v</td><td>区块选择，可以用长方形的方式选择数据</td></tr><tr><td>y</td><td>将反白的地方复制起来</td></tr><tr><td>d</td><td>将反白的地方删除掉</td></tr><tr><td>p</td><td>将刚刚复制的区块，在光标所在处贴上！</td></tr></tbody></table></div><p><strong>VIM补全</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">组合按钮</th><th style="text-align:left">补齐的内容</th></tr></thead><tbody><tr><td style="text-align:left">[ctrl]+x -&gt; [ctrl]+n</td><td style="text-align:left">通过目前正在编辑的这个“文件的内容文字”作为关键字，予以补齐</td></tr><tr><td style="text-align:left">[ctrl]+x -&gt; [ctrl]+f</td><td style="text-align:left">以当前目录内的“文件名”作为关键字，予以补齐</td></tr><tr><td style="text-align:left">[ctrl]+x -&gt; [ctrl]+o</td><td style="text-align:left">以扩展名作为语法补充，以 vim 内置的关键字，予以补齐</td></tr></tbody></table></div><p><strong>换行</strong></p><p>windows和Linux的换行符不一致，所以要注意使用 unix2dos 或 dos2unix进行转换。</p><h2 id="Linux快捷键"><a href="#Linux快捷键" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h2><ul><li>tab补全： 命令补全；文件补全；选项补全(—)</li><li>ctrl+c:强制结束</li><li>ctrl+d:离开命令行</li><li>[shift]+{[PageUP]|[Page Down]}按键：上下翻页，仅限在命令行内</li></ul><p>编辑器快捷键</p><div class="table-container"><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>空白键</td><td>向下翻一页</td></tr><tr><td>[Page Down]</td><td>向下翻一页</td></tr><tr><td>[Page Up]</td><td>向上翻一页</td></tr><tr><td>[Home]</td><td>去到第一页</td></tr><tr><td>[End]</td><td>去到最后一页</td></tr><tr><td>/string</td><td>向“下”搜寻 string 这个字串，如果要搜寻 vbird 的话，就输入 /vbird</td></tr><tr><td>?string</td><td>向“上”搜寻 string 这个字串</td></tr><tr><td>n, N</td><td>利用 / 或 ? 来搜寻字串时，可以用 n 来继续下一个搜寻 （不论是 / 或 ?） ，可以利用 N 来进行“反向”搜寻。举例来说，我以 /vbird 搜寻 vbird 字串， 那么可以 n 继续往下查询，用 N 往上查询。若以 ?vbird 向上查询 vbird 字串， 那我可以用 n 继续“向上”查询，用 N 反向查询。</td></tr><tr><td>q</td><td>结束这次的 man page</td></tr></tbody></table></div><p>cd 选项</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">.  </span>代表此层目录</span><br><span class="line"><span class="bullet">..        </span>代表上一层目录</span><br><span class="line"><span class="bullet">-         </span>代表前一个工作目录</span><br><span class="line">~         代表“目前使用者身份”所在的主文件夹</span><br><span class="line">~account  代表 account 这个使用者的主文件夹（account是个帐号名称）</span><br></pre></td></tr></table></figure><p>安装包</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -<span class="selector-tag">i</span> deb包</span><br></pre></td></tr></table></figure><p>运行python脚本</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python database_preprocess<span class="selector-class">.py</span> &gt; run<span class="selector-class">.log</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><p>设置python source_root路径</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL_FOLDER/NS_policy_recommendation/ns_ai_system&gt; venv/<span class="class"><span class="keyword">lib</span>/<span class="title">python3</span>.6/<span class="title">site</span>-<span class="title">packages</span>/<span class="title">ns_ai_system</span>.<span class="title">pth</span></span></span><br></pre></td></tr></table></figure><p>观察文件类型</p><p>可以简单的判断这个文件的格式</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># file ~/.bashrc</span></span><br><span class="line"><span class="regexp">/root/</span>.bashrc: ASCII text  &amp;lt;==告诉我们是 ASCII 的纯文本文件啊！</span><br></pre></td></tr></table></figure><p>查看磁盘容量</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df -h<span class="comment"># 将系统内所有的 filesystem整体磁盘使用量</span></span><br><span class="line">df -h <span class="string">/etc</span> <span class="comment">#将该目录或文件所在的 partition容量显示</span></span><br></pre></td></tr></table></figure><p>查看文件占磁盘容量</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">du -sh</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux学习&lt;/p&gt;
    
    </summary>
    
      <category term="项目管理" scheme="http://kodgv.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="linux" scheme="http://kodgv.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文档</title>
    <link href="http://kodgv.xyz/2019/05/16/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Linux%E6%89%8B%E5%86%8C/"/>
    <id>http://kodgv.xyz/2019/05/16/项目管理/Linux手册/</id>
    <published>2019-05-16T12:54:54.000Z</published>
    <updated>2019-07-31T07:43:00.855Z</updated>
    
    <content type="html"><![CDATA[<p>Linux学习</p><p>[TOC]</p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>搜狗拼音：<a href="https://blog.csdn.net/lupengCSDN/article/details/80279177" target="_blank" rel="noopener">https://blog.csdn.net/lupengCSDN/article/details/80279177</a></p><p>java安装：<a href="http://www.manongjc.com/article/34273.html" target="_blank" rel="noopener">http://www.manongjc.com/article/34273.html</a></p><p>extundelete:恢复删除文件（先安装才能恢复）</p><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>docker远程服务器连接：<a href="https://blog.csdn.net/hanchaobiao/article/details/84069299" target="_blank" rel="noopener">https://blog.csdn.net/hanchaobiao/article/details/84069299</a></p><p>linux命令：&lt;<a href="https://wangchujiang.com/linux-command/list.html#!kw=%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener">https://wangchujiang.com/linux-command/list.html#!kw=%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95</a></p><h3 id="手工分区和挂载硬盘"><a href="#手工分区和挂载硬盘" class="headerlink" title="手工分区和挂载硬盘"></a>手工分区和挂载硬盘</h3><p><img src="/2019/05/16/项目管理/Linux手册/Linux/1" alt="1564390257963"><img src="/2019/05/16/项目管理/Linux手册/Linux/2" alt="1564390299820"></p><p><img src="/2019/05/16/项目管理/Linux手册/Linux/3" alt="1564390325355"></p><p><img src="/2019/05/16/项目管理/Linux手册/Linux/4" alt="1564390354190"></p><p><img src="/2019/05/16/项目管理/Linux手册/Linux/5" alt="1564390380598"></p><p><img src="/2019/05/16/项目管理/Linux手册/Linux/6" alt="1564390405790"></p><h3 id="统计分区使用率"><a href="#统计分区使用率" class="headerlink" title="统计分区使用率"></a>统计分区使用率</h3><p><img src="/2019/05/16/项目管理/Linux手册/Linux/7" alt="1564399542685"></p><h3 id="监听apache自动重启"><a href="#监听apache自动重启" class="headerlink" title="监听apache自动重启"></a>监听apache自动重启</h3><p><img src="/2019/05/16/项目管理/Linux手册/Linux/8" alt="1564399592746"></p><h3 id="批量解压缩脚本"><a href="#批量解压缩脚本" class="headerlink" title="批量解压缩脚本"></a>批量解压缩脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ls *.tar.gz &gt; ls.log</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(cat ls.log)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">tar -zxf <span class="variable">$i</span> &amp;&gt;/dev/null</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">rm -rf ls.log</span><br></pre></td></tr></table></figure><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>看pdf</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux学习&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;软件安装&quot;&gt;&lt;a href=&quot;#软件安装&quot; class=&quot;headerlink&quot; title=&quot;软件安装&quot;&gt;&lt;/a&gt;软件安装&lt;/h3&gt;&lt;p&gt;搜狗拼音：&lt;a href=&quot;https://blog.csdn.ne
      
    
    </summary>
    
      <category term="项目管理" scheme="http://kodgv.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="linux" scheme="http://kodgv.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>重构与规范</title>
    <link href="http://kodgv.xyz/2019/05/16/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%87%8D%E6%9E%84%E4%B8%8E%E8%A7%84%E8%8C%83/"/>
    <id>http://kodgv.xyz/2019/05/16/项目管理/重构与规范/</id>
    <published>2019-05-16T08:37:43.000Z</published>
    <updated>2019-09-01T03:22:22.690Z</updated>
    
    <content type="html"><![CDATA[<p>代码整洁规范<br>减少重复代码<br>提高表达力<br>提早构建简单抽象<br><a id="more"></a></p><p>[TOC]</p><h1 id="代码整洁"><a href="#代码整洁" class="headerlink" title="代码整洁"></a>代码整洁</h1><h2 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h2><p><strong>名副其实</strong></p><ul><li>如果你需要注释来解释一个变量，那就说明它不是名副其实</li><li>一旦发现有更好的命名，就要换掉旧的，要记住换花的时间是值得的</li></ul><p><strong>避免误导</strong></p><ul><li>尽量少使用类型名，除非它真的是这个类型</li><li>不要使用过于相似的名字</li></ul><p><strong>命名规范</strong></p><ul><li>类名和对象是名词，方法是动词，注意get/set/is的前缀</li><li>即每个抽象概念选一个词，DeviceManager和Protocal-Controller是一样的</li><li>要保持前后术语规范。</li><li>用常量代替原始数字（魔术数）</li><li>不要在代码中重复写+1的边界条件，而是用变量进行封装</li><li>函数的长短与其作用范围息息相关，所以for循环可以用i,j因为它们作用域很小</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数要做到自己理解，而不是通过测试用例，这需要改进和重构简洁。</p><p><strong>尽量短小</strong></p><ul><li>if/for/while中应该只有一行</li><li>函数只做一件事，抽象层上应该是同一级别！</li><li>函数的顺序，是自顶向下的规则，抽象到具体的顺序</li></ul><p><strong>参数</strong></p><ul><li>参数最多不应该超过3个，如果参数多于3个的时候，就可以思考参数是否能构成一个类，参数过多的时候可以组合成字典传递</li><li>参数不要传布尔值，应该将true/false分成两个函数，然后在布尔值的上一个抽象层直接做判断，而不是将其作为布尔值传递。（整数值，枚举元素等函数选择行为同理）</li><li>参数不要传字面值，应传变量</li><li>最好保证对象的拷贝性，统一拷贝而不是在原值上修改</li></ul><p><strong>返回值</strong></p><ul><li>可以定义这样的规范，每个函数的返回值都叫result</li></ul><p><strong>处理异常</strong></p><ul><li>try/catch的每个功能都应该拆出成一个函数</li><li>如果你用枚举类型来表示异常，那将意味着你会很不情愿修改它，使用异常代替错误码，新异常就可以从异常类中派生出来.</li></ul><p><strong>重复</strong></p><ul><li>永远无法容忍重复代码，这意味着抽象的遗漏</li><li>如果你发现死代码（永不执行的代码块），果断删除</li><li>多个switch/ifelse，考虑多态</li></ul><p><strong>判断</strong></p><ul><li>if的条件如果过多，就要封一个函数，因为没有上下文是看不懂if的</li><li>避免否定条件，尽量保持一致，不要带！，可以直接把！函数封成函数</li></ul><p><strong>静态</strong></p><ul><li>如果一个函数不依赖其类的属性，都是依赖于参数，这时候该函数就应该声明为静态</li><li>静态导入（就是单纯导入），而不是用继承的方式，这样别人不知道函数的来源</li></ul><p><strong>变量</strong></p><p>个人喜欢在第一次需要使用变量的地方声明，而不是在顶部一口去声明</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>尽量少写注释</strong></p><ul><li>写注释意味着你的代码不够优雅，别人无法理解</li><li>能用函数和变量拆解的时候就拆解，而不是用注释去描述</li><li>你无法始终坚持维护你的注释，会出现各种问题</li><li>不要注释代码，我们有优秀的代码管理器，无用的代码就删掉就可以了，它会保留的。</li></ul><p><strong>好的注释</strong></p><ul><li>法律与版本信息</li><li>某个决定背后的意图解释，便于后续别人的修改</li><li>TODO</li></ul><p><strong>如何写注释</strong></p><ul><li>一旦写注释就要花时间写好注释，注释的角度尽量从别人的角度出来来想会有什么疑惑，而不是解决自己的疑惑</li><li>不要尝试描述代码本身</li></ul><h2 id="数据，对象的反对称性"><a href="#数据，对象的反对称性" class="headerlink" title="数据，对象的反对称性"></a>数据，对象的反对称性</h2><p><strong>抽象</strong></p><ul><li>隐藏实现并非在变量之间放上一层函数层，也不是单纯使用取值器和赋值器往外推，而是暴露抽象接口，以便于用户无需了解数据形式就可以操作数据。</li><li>过程式代码便于添加函数（switch实现）；对象类代码便于添加数据类型（多态实现）</li><li>DTO(data transfer object)，豆结构，即只有赋值器和取值器操作的私有变量</li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><strong>try-catch</strong></p><ul><li>try-catch: 一开始可以用exception捕捉，捕捉到之后要缩小到对应范围。</li><li>try的内容是一个原子事务，这一点要注意想清楚。</li></ul><p><strong>NULL值处理</strong></p><ul><li>绝对不要返回Null值，否则别人检查null值会很麻烦，而且检查一多就会乱(可以内部直接抛出错误，也可以定义为空值就好)</li><li>禁止参数传入Null值，否则你总不可能每个变量一个个检查null（如果实在没有办法就只能用断言assert检查一下吧，用if有时会太乱混淆）</li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><strong>短小</strong></p><ul><li>类的名称要描述其权责而不能是一些模糊的词（Process,manger,super），而且描述该类职责的时候不应该出现if/and/or/but这些词语</li><li>类的权责应该是单一的，尽量拆成多个短小类吧</li><li>长的函数拆成小的函数的时候，参数是否要传，若是那为什么不把它们变成一个类，参数是它们的成员变量就好了。注意变的时候保持单一权责</li><li>注意职责的分隔。如果当你新增一个功能可能会影响其他时，说明耦合过强</li></ul><h2 id="好的代码示范"><a href="#好的代码示范" class="headerlink" title="好的代码示范"></a>好的代码示范</h2><p>书的附录记录了好的代码示范</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 优秀的缩减了代码的长度，在简单代码的情况下，简洁是第一要义。所以允许在前面<span class="keyword">return</span></span><br><span class="line"><span class="keyword">public</span> boolean addCustomer(Customer customer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.customers.length == <span class="keyword">this</span>.total) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       customers[total++] = customer;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><h3 id="重构的过程"><a href="#重构的过程" class="headerlink" title="重构的过程"></a>重构的过程</h3><p>发生的时间：</p><ul><li>当你想要给程序添加一个新特性的时候。</li><li>营地法则：保证你离开时的代码库一定比来时更健康。</li></ul><p>第一步：</p><ul><li>确保即将修改的代码拥有一组可靠的测试。</li></ul><p>第二步：</p><ul><li>从整个代码中分离出不同的关注点。</li><li>提炼代码到新的函数，关注又那些变量会离开原本的作用域</li><li>每走一步都需要测试一遍，保证不会出错</li></ul><p>第三步：</p><ul><li>提炼出新的函数后首先关注变量改名</li><li>关注函数的参数之间关系，是否真的需要传入</li></ul><p>第四步：</p><ul><li>去除临时变量，用内联函数进行替代。（我不太喜欢，因为内联函数名字比较长）</li><li>检查变量是否可以合并或去除。</li></ul><p>第五步：</p><ul><li>检查循环，将不同的任务拆分，可以允许多个循环，如果重构引入性能损耗，先完成重构，再做性能优化。</li></ul><p>第六步：</p><ul><li>拆分计算阶段与格式阶段，即输出的时候格式可能会经常需要变动，避免重复的代码，应定义一个对象的格式作为计算阶段与格式阶段的交互。</li></ul><p>第七步：</p><ul><li>多态取代条件表达式，如switch等 </li></ul><p>注意事项</p><ul><li>为了简洁，在不会有太大变动的部分，可以采用一些不好的习惯。</li></ul><h3 id="重构的原则"><a href="#重构的原则" class="headerlink" title="重构的原则"></a>重构的原则</h3><ul><li>重构是一个个小步骤，不是在迭代阶段的最后才执行的事情。</li><li>添加新功能时不应该修改已有代码，只管新功能，两顶帽子（重构和增加），每次只戴一顶</li><li>重构的时机：在添加新功能之前；当你需要思考这段代码到底在做什么；不需要重构的时机：不会有改动的地方，可以被API隐藏</li><li>面对遗留代码，不建议一股脑全部重构，更愿意随时重构相关代码，每碰到一块代码都保持营地法则。</li></ul><h3 id="什么情况下重构"><a href="#什么情况下重构" class="headerlink" title="什么情况下重构"></a>什么情况下重构</h3><p>结合重构的过程</p><ul><li>奇怪命名与重复代码</li><li>过长的函数，当你感觉要注释的时候，就需要把这一部分提取到一个独立的函数中</li><li>全局变量，全局变量要么是常量要么就提供get/set方法。</li><li>可变数据（可以建立原则：如果更新一个数据结构，就返回一个全新的数据副本）</li><li>发散式变化 ，即同一个模块需要根据不同的原因发生变化，就要考虑是否可以拆分</li><li>数据泥团，许多参数都喜欢糅杂，所以要用类去为它瘦身（很常见，数据项会经常很多）</li><li>纯数据类常常以为这行为被放在了错误的地方，只要把处理数据的行为搬移到纯数据类里，就可以使情况大大改善。</li></ul><h3 id="构筑测试体系"><a href="#构筑测试体系" class="headerlink" title="构筑测试体系"></a>构筑测试体系</h3><p>编写优良的测试程序，可以极大提高自我的编程速度，即使不进行重构也一样如此。</p><p>测试法则</p><ul><li>测试不是要把所有的错误找出来，所以你大可不必担忧繁杂的代码，而是让你更有自信的进行下一步。则保证核心主线功能正确</li><li>不是再每次迭代结尾时增加测试，而是只要写好一点功能就添加它们</li><li>TDD测试驱动开发，为了添加这个功能，我需要写什么测试函数。</li><li>注意测试代码中那些重用的对象，有可能不同测试函数之间产生干扰导致结果出错。</li><li>每当你遇见一个bug，先写一个测试来清楚地复现它。</li></ul><h3 id="重构手法目录"><a href="#重构手法目录" class="headerlink" title="重构手法目录"></a>重构手法目录</h3><p>需要的时候翻书</p><h4 id="提炼函数"><a href="#提炼函数" class="headerlink" title="提炼函数"></a>提炼函数</h4><p>函数提取</p><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>函数的合并与删除</p><h4 id="提炼变量"><a href="#提炼变量" class="headerlink" title="提炼变量"></a>提炼变量</h4><p>变量的提取</p><h4 id="内联变量"><a href="#内联变量" class="headerlink" title="内联变量"></a>内联变量</h4><p>变量的删除</p><h4 id="函数声明修改"><a href="#函数声明修改" class="headerlink" title="函数声明修改"></a>函数声明修改</h4><p>修改函数声明 </p><h4 id="封装变量"><a href="#封装变量" class="headerlink" title="封装变量"></a>封装变量</h4><p>执行变量封装（数据作用域越大，封装越重要）</p><h4 id="引入参数对象"><a href="#引入参数对象" class="headerlink" title="引入参数对象"></a>引入参数对象</h4><p>把参数提取成新类的成员，能够有更好的拓展性，和概念性</p><h4 id="函数组合成类"><a href="#函数组合成类" class="headerlink" title="函数组合成类"></a>函数组合成类</h4><p>通过封装将函数和变量组合成类</p><h4 id="封装记录"><a href="#封装记录" class="headerlink" title="封装记录"></a>封装记录</h4><p>对于可变的数据结构（散列，字典）转变为类</p><p>返回的可变数据是地址值，注重是否需要拷贝</p><h4 id="封装集合"><a href="#封装集合" class="headerlink" title="封装集合"></a>封装集合</h4><p>封装可变变量常犯的错误：只对访问进行了封装，依旧让取值函数返回变量本身。</p><ul><li>返回值是否需要拷贝</li><li>参数传入时是否需要拷贝</li><li>养成可变对象都采用拷贝的方法</li></ul><h4 id="以对象取代基本类型"><a href="#以对象取代基本类型" class="headerlink" title="以对象取代基本类型"></a>以对象取代基本类型</h4><p>或许一开始这个类只是简单包装，但只要类有了，日后添加的业务逻辑就有地可取。面向对象这是最实用的重构手法之一—-新手常忽略</p><h4 id="以查询取代临时变量"><a href="#以查询取代临时变量" class="headerlink" title="以查询取代临时变量"></a>以查询取代临时变量</h4><p>用函数来代替临时变量：只适用于那些只计算以此且之后不再被修改的变量。</p><h4 id="搬移函数"><a href="#搬移函数" class="headerlink" title="搬移函数"></a>搬移函数</h4><p>检查函数当前上下文与目标上下的区别进行函数的移动，或通用或更紧密</p><h4 id="搬移字段"><a href="#搬移字段" class="headerlink" title="搬移字段"></a>搬移字段</h4><p>类成员的移动，还原更好的 更少修改的数据结构</p><h4 id="搬移语句到函数"><a href="#搬移语句到函数" class="headerlink" title="搬移语句到函数"></a>搬移语句到函数</h4><p>黄金法则：消除重复代码</p><h4 id="移动代码"><a href="#移动代码" class="headerlink" title="移动代码"></a>移动代码</h4><p>黄金发着：如果移动代码中的变量在另一个地方被修改，则需要认真检查代码的关联性。</p><p>重新组织数据：</p><h4 id="拆分循环"><a href="#拆分循环" class="headerlink" title="拆分循环"></a>拆分循环</h4><p>拆分循环，让一个循环只做一件事情，可以放弃性能from pyhanlp import HanLP</p><h4 id="字段改名"><a href="#字段改名" class="headerlink" title="字段改名"></a>字段改名</h4><p>如果记录的作用域较小则可以直接改，如果记录在多出用到，则需要将其封装为类，提供访问和修改的方法，这样可以大大减少出错。</p><h4 id="以查询取代派生变量"><a href="#以查询取代派生变量" class="headerlink" title="以查询取代派生变量"></a>以查询取代派生变量</h4><p>即把数据的修改统一变成查询函数中进行。不要在其他的函数中进行变量的修改。比如每次修改都需要加100金额，这个操作可以放在查询中统一运行一次。</p><h4 id="把引用对象改为值对象"><a href="#把引用对象改为值对象" class="headerlink" title="把引用对象改为值对象"></a>把引用对象改为值对象</h4><p>保证对象的不可变性，当需要传入对象或者使用内部对象时，利用属性重新new一个新对象  </p><h4 id="把值对象改为引用对象"><a href="#把值对象改为引用对象" class="headerlink" title="把值对象改为引用对象"></a>把值对象改为引用对象</h4><p>对于一个客观实体，只有一个代表它的对象。这意味着我需要某种形式的仓库，在仓库中可以找到所有这些实体对象。直为每个实体创建一次对象，以后始终从仓库中获取改对象。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始化：构建<span class="meta">MAP</span>仓库</span><br><span class="line">构建对象：如果没有重复id就新建对象加入<span class="meta">Map</span>中</span><br><span class="line">获取对象：根据MAPkey获取对象</span><br><span class="line">仓库对象可以是单例的</span><br></pre></td></tr></table></figure><p><strong>有多对一的关系，都需要考虑这个</strong></p><h4 id="分解条件表达式"><a href="#分解条件表达式" class="headerlink" title="分解条件表达式"></a>分解条件表达式</h4><p>把条件分支中各个部分提炼函数，包括条件的判断，执行的语句。可以让人更好的关注判断本身而不用考虑具体逻辑。</p><h4 id="合并条件表达式"><a href="#合并条件表达式" class="headerlink" title="合并条件表达式"></a>合并条件表达式</h4><p>一连串的条件检查:检查条件各不相同，最终的行为却一致，就可以将它们合并为一个表达式，并用分解条件表达式来提炼函数。</p><h4 id="以return-语句取代嵌套条件表达式"><a href="#以return-语句取代嵌套条件表达式" class="headerlink" title="以return 语句取代嵌套条件表达式"></a>以return 语句取代嵌套条件表达式</h4><p>if else if else等多重嵌套循环，可以转变为if return if return 核心逻辑。保证了：如果这个情况不是该函数核心逻辑所关心的，如果它发生了，请做一些必要的整理工作，然后退出。</p><p>如果存在多重if嵌套，但是没有else的情况，可以使用反转逻辑表达式来解决提取核心逻辑</p><h4 id="引入特例"><a href="#引入特例" class="headerlink" title="引入特例"></a>引入特例</h4><p>1.把检查特殊情况的逻辑变成方法或者数据结构，只管引用或调用，逻辑只写一次</p><p>2.为数据结构添加特殊情况的结构，这样就省了每次检查都写特殊情况的逻辑</p><h4 id="将查询函数与修改函数分离"><a href="#将查询函数与修改函数分离" class="headerlink" title="将查询函数与修改函数分离"></a>将查询函数与修改函数分离</h4><p>任何有返回值的函数都不应该有副作用</p><h4 id="函数参数化合并"><a href="#函数参数化合并" class="headerlink" title="函数参数化合并"></a>函数参数化合并</h4><p>通过增加参数，把具有相似逻辑的函数合并。注意合并是为了减少重复，而不是单纯的赋值过来加switch case</p><h4 id="移除标记参数"><a href="#移除标记参数" class="headerlink" title="移除标记参数"></a>移除标记参数</h4><p>参数不应该作为标记传入，当发现函数需要传入一些字面量，而非变量的时候，就需要考虑拆解和优化</p><h4 id="保持对象的完整性"><a href="#保持对象的完整性" class="headerlink" title="保持对象的完整性"></a>保持对象的完整性</h4><p>如果是要从对象中拆解参数传给函数，那还不如把这个对象传给函数，在函数内部再进行拆解</p><h4 id="移除设值函数"><a href="#移除设值函数" class="headerlink" title="移除设值函数"></a>移除设值函数</h4><p>如果不希望在对象创建后此字段还有机会被改变，就不要为它提供设值函数（同时该字段声明为不可变）</p><h4 id="将复杂的函数转为对象-将复杂的对象转为函数"><a href="#将复杂的函数转为对象-将复杂的对象转为函数" class="headerlink" title="将复杂的函数转为对象==将复杂的对象转为函数"></a>将复杂的函数转为对象==将复杂的对象转为函数</h4><h3 id="针对继承"><a href="#针对继承" class="headerlink" title="针对继承"></a>针对继承</h3><h4 id="函数上下移动和属性上下移动"><a href="#函数上下移动和属性上下移动" class="headerlink" title="函数上下移动和属性上下移动"></a>函数上下移动和属性上下移动</h4><h4 id="构造函数上移"><a href="#构造函数上移" class="headerlink" title="构造函数上移"></a>构造函数上移</h4><p>将非子类特有的属性放在父类的构造函数中初始化</p><h4 id="以子类取代类型码"><a href="#以子类取代类型码" class="headerlink" title="以子类取代类型码"></a>以子类取代类型码</h4><p>如果有类型的情况，就可以考虑多态。不过要在多态的操作的复杂性和语义的简洁扩展中选择（工厂函数提供不同的构造函数）</p><h4 id="提炼超类"><a href="#提炼超类" class="headerlink" title="提炼超类"></a>提炼超类</h4><p>利用基本的继承机制将两个类的相似之处提炼到超类</p><h4 id="折叠继承体系"><a href="#折叠继承体系" class="headerlink" title="折叠继承体系"></a>折叠继承体系</h4><p>将子类和超类合并为一个类</p><h4 id="以委托取代子类"><a href="#以委托取代子类" class="headerlink" title="以委托取代子类"></a>以委托取代子类</h4><p>将子类用另外一个类取代，将继承的关系变为组合的关系，在父类中用if来决定调用父类还是子类（个人没看出优点）</p><h4 id="以委托取代父类"><a href="#以委托取代父类" class="headerlink" title="以委托取代父类"></a>以委托取代父类</h4><p>子类只需要用到父类的一部分，将父类变成子类的一个属性，并初始化为父类的实例，然后就可以通过这个属性调用父类，从而去除继承关系。</p><h4 id="UML类交互图"><a href="#UML类交互图" class="headerlink" title="UML类交互图"></a>UML类交互图</h4><p>越是复杂的逻辑，就越需要画清楚uml的交互关系</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码整洁规范&lt;br&gt;减少重复代码&lt;br&gt;提高表达力&lt;br&gt;提早构建简单抽象&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="项目管理" scheme="http://kodgv.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="代码规范" scheme="http://kodgv.xyz/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>elo比赛心得</title>
    <link href="http://kodgv.xyz/2019/04/30/%E7%AB%9E%E8%B5%9B%E7%BB%8F%E9%AA%8C/elo%E6%AF%94%E8%B5%9B%E5%BF%83%E5%BE%97/"/>
    <id>http://kodgv.xyz/2019/04/30/竞赛经验/elo比赛心得/</id>
    <published>2019-04-30T11:30:59.000Z</published>
    <updated>2019-05-25T12:36:31.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比赛简介"><a href="#比赛简介" class="headerlink" title="比赛简介"></a>比赛简介</h2><ul><li>回归问题</li><li><p>有异常点</p></li><li><p>商品信息，</p></li><li>每个用户的刷卡时间。</li><li>预测用户的忠诚度。</li></ul><a id="more"></a><p>[TOC]</p><h2 id="11th-place-solution"><a href="#11th-place-solution" class="headerlink" title="11th place solution"></a><a href="https://www.kaggle.com/c/elo-merchant-category-recommendation/discussion/82127#latest-502682" target="_blank" rel="noopener">11th place solution</a></h2><p><strong>FEATURE ENGINEERING</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> I refer the Kaggle Rank System Compute Formula（link:[https://www.kaggle.com/progression][<span class="number">4</span>])</span><br><span class="line">    df_data[<span class="string">'duration_sqrt_counts'</span>] = df_data[<span class="string">'durations'</span>]/sqrt(df_data[<span class="string">'card_id_counts'</span>])</span><br><span class="line">    df_data[<span class="string">'duration_log1p_counts'</span>] = df_data[<span class="string">'durations'</span>]/log1p(df_data[<span class="string">'card_id_counts'</span>])</span><br><span class="line">    df_data[<span class="string">'duration_counts'</span>] = df_data[<span class="string">'durations'</span>]/df_data[<span class="string">'card_id_counts'</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Categorical features: frequence, Maxfrequence, MaxfrequenceRatio</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> card_id/merchant_id/mechant_category_id/city_id (visit sequence to sequence embedding)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> purchase_amount:hist/new</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> features interactions between hist/new</span><br><span class="line">            df[<span class="string">'purchase_amount_ratio_v3'</span>] =                              df[<span class="string">'new_purchase_amount_max'</span>]/df[<span class="string">'hist_purchase_amount_sum'</span>]</span><br><span class="line">            df[<span class="string">'purchase_amount_diff_v1'</span>] = df[<span class="string">'new_purchase_amount_sum'</span>]-df[<span class="string">'hist_purchase_amount_sum'</span>]</span><br><span class="line">            df[<span class="string">'purchase_amount_diff_v2'</span>] = df[<span class="string">'new_purchase_amount_mean'</span>]-df[<span class="string">'hist_purchase_amount_mean'</span>]</span><br><span class="line">            df[<span class="string">'purchase_amount_diff_v3'</span>] = df[<span class="string">'new_purchase_amount_max'</span>]-df[<span class="string">'hist_purchase_amount_max'</span>]</span><br><span class="line">            df[<span class="string">'purchase_amount_diff_v4'</span>] = df[<span class="string">'new_purchase_amount_min'</span>]-df[<span class="string">'hist_purchase_amount_min'</span>]</span><br><span class="line">            df[<span class="string">'pa_mlag_ratio'</span>] = df[<span class="string">'new_purchase_amount_sum'</span>]/(df[<span class="string">'month_lag_mean'</span>] - <span class="number">1</span>)</span><br><span class="line">            df[<span class="string">'pa_new_hist_ratio'</span>] = df[<span class="string">'new_purchase_amount_sum'</span>]/(df[<span class="string">'hist_purchase_amount_sum'</span>])</span><br><span class="line">            df[<span class="string">'pa_new_hist_mean_ratio'</span>] = df[<span class="string">'new_purchase_amount_mean'</span>]/(df[<span class="string">'hist_purchase_amount_mean'</span>] )</span><br><span class="line">            df[<span class="string">'pa_new_hist_min_ratio'</span>] = df[<span class="string">'new_purchase_amount_min'</span>]/(df[<span class="string">'hist_purchase_amount_min'</span>] )</span><br><span class="line">            df[<span class="string">'pa_new_hist_max_ratio'</span>] = df[<span class="string">'new_purchase_amount_max'</span>]/(df[<span class="string">'hist_purchase_amount_max'</span>] )</span><br></pre></td></tr></table></figure><p>我们有两个单独的feature sets。一个具有+1000个feature ，另一个具有+200个feature </p><p>然后，我们取+200特征集的相关矩阵，<strong>将每个特征与其关联最小的特征配对。然后我们对每一对应用了大量的聚合</strong>，结果得到了非常强大的特征。</p><p>所以我们最终得到了两个功能集，每个功能集+1000个功能。”</p><p><strong>STACKING</strong></p><p>We stacked around 32 models using bayesian regression. Our models were well varied that it yielded a score of CV:3.630X LB :3.675</p><p><strong>STUFF THAT DID NOT WORK</strong></p><p>Of course these last two months were not all roses and rainbows. We pulled our hair trying a lot of things and we failed miserably.</p><p>Here are the bloopers of our participation :D :</p><ul><li>NN. We tried designing different architectures with the main focus on having a simple NN with heavy regularization (BatchNorm and Strong Dropout)</li><li>In the middle of the competition, we tried tackling the outliers detection as an anomaly detection problem using AutoEncoders trained only on the non outliers data</li><li>We tried PCA for more features. And it didn’t work</li><li>We tried TSNE. It didn’t work</li><li>We tried FM and FFM. It did not work</li><li>We tried isolation forest. Nope. Did not work.</li><li>We had a Ridge-based pairwise ranker that we intended to use for outliers detection but it didn’t match with the approach we had.</li><li>We tried a lot of weak models in the hope of adding diversity (simple tree-based, linear, svm, etc.). And guess what? It did not work.</li></ul><p>如何识别异常点？</p><p>两个不同的特征集怎么做？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;比赛简介&quot;&gt;&lt;a href=&quot;#比赛简介&quot; class=&quot;headerlink&quot; title=&quot;比赛简介&quot;&gt;&lt;/a&gt;比赛简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;回归问题&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有异常点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;商品信息，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;每个用户的刷卡时间。&lt;/li&gt;
&lt;li&gt;预测用户的忠诚度。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="特征工程" scheme="http://kodgv.xyz/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="机器学习" scheme="http://kodgv.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java核心技术基础知识</title>
    <link href="http://kodgv.xyz/2019/04/30/JAVA%E5%AD%A6%E4%B9%A0/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>http://kodgv.xyz/2019/04/30/JAVA学习/java核心技术/</id>
    <published>2019-04-30T11:30:59.000Z</published>
    <updated>2019-08-18T11:53:19.578Z</updated>
    
    <content type="html"><![CDATA[<p>java基础知识<br><a id="more"></a></p><p>[TOC]</p><h2 id="java程序设计环境"><a href="#java程序设计环境" class="headerlink" title="java程序设计环境"></a>java程序设计环境</h2><p><img src="/2019/04/30/JAVA学习/java核心技术/1" alt="1557976698685"></p><ul><li><p>JDK 是 Java Development Kit 的缩写开发人员必须要安装，Java 运行时环境（JRE), 它包含虚拟机 但不包含编译器。</p></li><li><p>Java SE 会大量出现， 相对于 Java EE ( Enterprise Edition) 和 Java ME ( Micro Edition), 它是 Java 的标准版。 </p></li></ul><h2 id="java基本程序设计结构"><a href="#java基本程序设计结构" class="headerlink" title="java基本程序设计结构"></a>java基本程序设计结构</h2><ul><li>类是构建所有 Java 应用程序和 applet 的构建块。Java 应用程序中的全部内容都必须放置在类中。 </li></ul><p><strong>数据类型</strong></p><p>整型</p><p><img src="/2019/04/30/JAVA学习/java核心技术/E:/bolg\source\_posts\JAVA学习\java核心技术\2" alt="1557977861052"></p><p>浮点型</p><p><img src="/2019/04/30/JAVA学习/java核心技术/E:/bolg\source\_posts\JAVA学习\java核心技术\3" alt="1557977876477"></p><p>有三种类型，正无穷大，负无穷大，NAN：</p><ul><li>Double_POSITIVE_INFINITY</li><li>Double.NEGATIVEJNFINITY </li><li>Double.NaN </li></ul><blockquote><p>NAN与任何数字包括NAN都不相等，不能用==Double.NaN,而是要用isNaN()</p></blockquote><p>字符型</p><p><strong>byte</strong></p><p>byte 字节，数据存储容量1byte，byte作为基本数据类型表示的也是一个存储范围上的概念，有别于int、long等专门存数字的类型，这种类型的大小就是1byte,而int是4byte。<br>存数字的话就是1byte=8位，2^8=256 即-128-127。字符的话包括字母和汉字，一个字母是1byte，一个汉字2byte。也就是可以用byte变量去存储一个英文字符，但是却存不下一个中文汉字，因为一个汉字占2byte。</p><p>总结，byte是java中的一个基本数据类型，这个数据类型的长度是1byte，此byte就是彼byte,即是基本数据类型也是存储空间的基本计量单位。</p><p><strong>char</strong></p><p>char是Java中的保留字，与别的语言不同的是，char在Java中是16位的，因为Java用的是Unicode。不过8位的ASCII码包含在Unicode中，是从0~127的。</p><p>Java中使用Unicode的原因是，Java的Applet允许全世界范围内运行，那它就需要一种可以表述人类所有语言的字符编码。Unicode。</p><p>char本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于Unicode编号，用于表示那个Unicode编号对应的字符。</p><p>由于固定占用两个字节，char只能表示Unicode编号在65536以内的字符，而不能表示超出范围的字符。</p><p><strong>Unicode</strong></p><p>需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p><p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p><p>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p><p>它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。</p><p><strong>UTF-8</strong></p><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。</p><p>以utf8为例，utf8是一个变长编码标准，可以以1~4个字节表示一个字符，而中文占3个字节，ascII字符占1个字节。</p><p>为什么我们在java里面可以用一个char来表示一个中文呢？</p><p>因为java是以unicode作为编码方式的。unicode是一个定长的编码标准，每个字符都是2个字节，也就是1个char类型的空间。</p><p>在编译时会把utf8的中文字符转换成对应的unicode来进行传输运算。</p><p>(<strong>总结</strong>)[<a href="https://www.zhihu.com/question/23374078" target="_blank" rel="noopener">https://www.zhihu.com/question/23374078</a>]</p><ul><li><p>unicode是编码集，UTF8只是实现方式</p></li><li><p>一个char可以储存一个中文字符，因为它是两个byte</p></li><li>UTF8采用8位动长的方式，可以节省内存，区别中英文</li><li>unicode不够的时候，会采取增补代码点，即用2个2位字节来表示增补字符</li></ul><p><strong>常量</strong></p><p>final 关键字  一旦赋值不能够再更改</p><p><strong>String 字符串</strong></p><p>Java 字符串就是 Unicode 字符序列。Java 没有内置的字符串类型， 而是在标准 Java类库中提供了 一个预定义类，很自然地叫做 String。它是不可变的对象，每次赋值都会新开一个内存空间。可以把string理解成是char*的指针。</p><p>不要用==来比较字符串，而是要使用s.equal(s1)的方式</p><p>它有null和“”空串，两种不同形式，if (str != null &amp;&amp; str.length != 0) </p><p><strong>格式化输出</strong></p><p><img src="/2019/04/30/JAVA学习/java核心技术/4" alt="1558017586500"></p><p>String message = String.format(“Hello, %s. Next year, you’ll be %d”, name, age); </p><p><strong>大数值</strong></p><p>Biglnteger类实现了任意精度的整数运算； BigDecimal 实现了任意精度的浮点数运算。它们没有+和*必须用内置的函数</p><p>Biglnteger a = Biglnteger.valueOf(100);<br>Biglnteger c = a.add(b); // c = a + b<br>Biglnteger d = c.nultipiy(b.add(Biglnteger.valueOf(2))); // d = c * (b + 2)</p><p><strong>数组</strong><br>int[ ] a = new int[100];<br>使用以下直接访问数组内的元素，它将会遍历数组， 而不需要使用下标值<br>for (int element : a)<br>​    System.out.println(element): </p><p>数组拷贝</p><p>浅拷贝： 两个变量将引用同 一个数组</p><p>深拷贝：int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length);（可以使用该方法增长数组长度）</p><p>数组排序：</p><p>Arrays.sort(a) </p><h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><p>要想使用 OOP, —定要清楚对象的三个主要特性： </p><ul><li><p>对象的行为（behavior)— —可以对对象施加哪些操作，或可以对对象施加哪些方法？ </p></li><li><p>对象的状态（state)— —当施加那些方法时，对象如何响应？ </p></li><li><p>对象标识（identity)— —如何辨别具有相同行为与状态的不同对象</p></li></ul><ul><li>对象状态的改变必须通过调用方法实现 </li><li>对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份（identity)。</li><li>对象的这些关键特性在彼此之间相互影响着。例如， 对象的状态影响它的行为（如果一 个订单 “ 已送货” 或“ 已付款”， 就应该拒绝调用具有增删订单中条目的方法。</li></ul><p>最常见类的关系：•依赖（ “ uses-a”） •聚合（ “ has-a”） •继承（is-a)</p><p>要用UML图画类的关系，设计的时候。</p><p><strong>对象变量</strong></p><p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象</p><blockquote><p>Date deadline<br>deadline = new Date()<br>deadline是对象变量，必须初始化它</p></blockquote><ul><li>只 访 问 对 象 而 不 修 改 对 象 的 方 法 有 时 称 为 访 问 器 方 法</li><li>修改对象的方法称更改器方法 ( mutator method ) </li><li>如果需要返回一个可变对象的引用， 应该首先对它进行克隆（clone)，否则破坏封装性。</li></ul><p><strong>构造器</strong></p><p>•构造器与类同名 </p><p>•每个类可以有一个以上的构造器 </p><p>•构造器可以有 0 个、1 个或多个参数 </p><p>•构造器没有返回值</p><p> •构造器总是伴随着 new 操作一起调用</p><p>关键字 this 表示隐式参数，就是说通过this.变量或方法来调用自身域内。</p><p><strong>final实例域</strong></p><p>实例域定义为 final。 构建对象时必须初始化这样的域。也就是说， 必须确保在每 一个构造器执行之后，这个域的值被设置， 并且在后面的操作中， 不能够再对它进行修改</p><p>private final String name;</p><p>final如果使用的是可变对象，那么只是说它不会指向其他位置，但是当前位置的内容仍然可以改变</p><p><strong>static 静态</strong></p><p>静态域：每一个对象对于所有的实例域 有自己的一份拷贝，对于静态域只有一个，它属于类，而不属于对象，所以可以直接类.静态域也可以调用。</p><p>静态方法：它只能访问静态域和显式参数（传参）无法访问实例域，一般直接用类.方法名使用</p><p><strong>方法参数</strong></p><p>call by value：表示方法接收的是调用者提供的值</p><p>call by reference：表示方法接收的是调用者提供的变量地址</p><p>java都是按值调用！！！只是当传入的时对象时，它拷贝的是对象引用~</p><blockquote><p>public static void tripieValue(double x) // doesn’t work<br>{ x = 3 * x; }<br>double percent = 10;<br>tripieValue(percent); </p></blockquote><p>1 ) x 被初始化为 percent 值的一个拷贝（也就 是 10 ) </p><p>2 ) x 被乘以 3后等于 30。 但是 percent 仍然 是 10</p><blockquote><p>public static void tripieSalary(Employee x)<br>{ x.raiseSa1ary(200); }<br>harry = new Employee(. . .);<br>tripieSalary(harry);</p></blockquote><p>1 ) X 被初始化为 harry 值的拷贝，这里是一个对象的引用。 </p><p>2 ) raiseSalary 方法应用于这个对象引用。x 和 harry 同时引用的那个 Employee 对象的薪 金提高了 200%。 </p><p>3 ) 方法结束后，参数变量 x 不再使用。当然，对象变量 harry 继续引用那个薪金增至 3 倍的雇员对象</p><p>比如说如果你用swap想交换两个对象是不行的，因为你交换的是两个拷贝后的对象，原对象无影响。</p><p><strong>对象构造</strong></p><p>重载：相同的名字、不同的参数，便产生了重载，重载的是签名，不能出现两个相同名字，相同参数，返回值不同的方法</p><p>默认域初始化 ：被自动初始化为默认值（0、false 或 null)</p><p>构造器：只有当你不提供任何构造器的时候，系统会提供一个默认的构造器，将所有域变量初始化为默认值。</p><p>this:当作是当前类的一个指针，而且可以在构造函数里面使用this(参数)，引用另一个构造函数。</p><p><strong>调用构造器的具体处理步骤：</strong></p><p>1 ) 所有数据域被初始化为默认值（0、false 或 null)。 </p><p>2 ) 按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块</p><p>3 ) 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</p><p> 4 ) 执行这个构造器的主体.</p><p><strong>包</strong></p><ul><li>import xx.*是不会有内存影响，有时会出现两个包下函数同名冲突</li><li>编译器不会检查目录结构，如果它没有在它声明的package下，不会出现编译错误，但是最终程序无法允许，虚拟机找不到类。</li></ul><p>可见性：</p><ul><li>public 的部分可以被任意的类使用</li><li>private 的部分只能被定义它们的类使用</li><li>果没有指定 public 或 private, 这个部分（类、方法或变量）可以被同一个包中的所有方法访问</li></ul><p><strong>文档注释</strong></p><p>javadoc, 它可以由源文件生成一个 HTML 文档</p><p>javadoc 实用程序（utility) 从下面几个特性中抽取信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> •包 </span><br><span class="line"></span><br><span class="line">•公有类与接口 </span><br><span class="line"></span><br><span class="line">•公有的和受保护的构造器及方法</span><br><span class="line"></span><br><span class="line"> •公有的和受保护的域</span><br></pre></td></tr></table></figure><p>类注释要放在import语句之后，类定义之前</p><p>方法注释放在方法之前。</p><p>@param 变量描述 这个标记将对当前方法的“ param” （参数）部分添加一个条目。这个描述可以占据多 行， 并可以使用 HTML 标记。一个方法的所有@param 标记必须放在一起。 </p><p>@return 描述 这个标记将对当前方法添加“ return” （返回）部分。这个描述可以跨越多行， 并可以 使用 HTML 标记。 </p><p>©throws 类描述 这个标记将添加一个注释， 用于表示这个方法有可能抛出异常。有关异常的详细内容。</p><p>@author 姓名 这个标记将产生一个 “author” (作者）条目。可以使用多个@author 标记，每个@ author 标记对应一个作者 </p><p>@version 这个标记将产生一个“ version”（版本）条目。这里的文本可以是对当前版本的任何描 述。 下面的标记可以用于所有的文档注释中。 </p><p>@since 文本 这个标记将产生一个“ since” （始于）条目。这里的 text 可以是对引人特性的版本描 述。例如，©since version 1.7.10</p><p>/<em>*<br>@param  car  ….</em>/</p><p><strong>类设计技巧</strong></p><ol><li>一定要保证数据私有</li><li>一定要对数据初始化 </li><li>不要在类中使用过多的基本类型（抽象）</li><li>不是所有的域都需要独立的域访问器和域更改器 （状态的相互影响）</li><li>类名和方法名要能够体现它们的职责</li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>简单介绍</strong></p><p>public class Manager extends Employee</p><ul><li>使用extends关键字</li><li>所有继承都是公有继承，没有C++中的私有继承</li><li>使用关键字super调用父类的方法</li><li>关键字 this 有两个用途： 一是引用隐式参数，二是调用该类其他的构 造器 ， 同样，super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。 </li></ul><p><strong>多态</strong></p><p>一个对象变量（例如， 变量 e) 可以指示多种实际类型的现象被称为多态（polymorphism)。 在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding)。</p><p>即函数写的是父类，但是调用时传入的是不同的子类，该父类可以自动调用多种实际类的覆盖方法</p><p><strong>方法调用顺序</strong></p><p>1.编译器査看对象的声明类型和方法名。编译器将会一一列举所有 C 类中名为 f 的方法和其超类中 访问属性为 public 且名为 f 的方法（超类的私有方法不可访问）</p><p>2.编译器将査看调用方法时提供的参数类型。如果在所有名为 f 的方法中存在 一个与提供的参数类型完全匹配，就选择这个方法。</p><p>至此， 编译器已获得需要调用的方法名字和参数类型。</p><p>3.静态绑定： 如果是 private 方法、 static 方法、final 方法，编译器将可以准确地知道应该调用哪个方法</p><p>4.动态绑定：调用的方法依赖于隐式参数的实际类型，在运行时虚拟机一定调用与 x 所引用对象的实 际类型最合适的那个类的方法</p><p>每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个 方法表（method table), 其中列出了所有方法的签名和实际调用的方法</p><p><strong>警告</strong>：在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。</p><p><strong>final 类和方法</strong> </p><p>不允许扩展的类被称为 final 类</p><p>类中的特定方法也可以被声明为 final。如果这样做，子类就不能覆盖这个方法（final 类中的所有方法自动地成为 final 方法)。写上会比较好，这样可以避免一些不必要的覆盖。</p><p>本包是指包名相同的情况下</p><p>1 ) 仅对本类可见 private。<br>2 ) 对所有类可见 public<br>3 ) 对本包和所有子类可见 protected。<br>4 ) 对本包可见— —默认（很遗憾)， 不需要修饰符</p><p><strong>Object</strong></p><p>这是所有类的超类，其有一些方法需要注意：</p><ul><li>equal 判断对象是否相等</li><li>hashCode 每个对象的储存地址</li><li>toString 返回表示对象值的字符 串</li></ul><p><strong>泛型数组列表</strong></p><p>ArrayList<employee> staff = new ArrayList<eniployee>（）; </eniployee></employee></p><p>它可以动态更改数组大小</p><p>数组列表管理着对象引用的一个内部数组。最终， 数组的全部空间有可能被用尽。这就显现出数组列表的操作魅力： 如果调用 add且内部数组已经满了，数组列表就将自动地创建 一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p><p>有两种声明长度的方法：</p><ol><li><p>ArrayList<employee> staff = new ArrayList&lt;&gt;(100);</employee></p><p>数组这样声明，系统会为数组分配100个元素的储存空间。而数组列表这样声明，只是表示拥有保存100个元素的潜力，在最初数组列表不会含有任何元素。</p></li><li><p>ensureCapacity(100）</p><p>如果已经清楚或能够估计出数组可能存储的元素数量， 就可以在填充数组之前调用 ensureCapacity方法，会分配一个包含100个对象的内部数组。</p></li></ol><p>API方法：</p><p>add：添加新元素</p><p>set：覆盖旧元素</p><p>get: 获取元素</p><p>remove:删除元素</p><p>注意对这类型的数组中间元素进行插入和删除，过程会比较费时</p><p>类型化与原始数组列表的兼容性<br>　　可以将一个类型化的数组列表传递给update方法，而不需要进行任何类型转换：即只要是ArrayList类对象，不管是什么具体类型化都可以编译通过。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = ...<span class="comment">;</span></span><br><span class="line">employeeDB.update(staff)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>　　但是，如果将一个原始的没有类型化的ArrayList赋值给一个类型化ArrayList就会得到警告：因为得到的可能不是Employee类的类型的数组列表</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; result = employeeDB.<span class="builtin-name">find</span>(<span class="built_in">..</span><span class="built_in">..</span>);</span><br></pre></td></tr></table></figure><p>　　这个时候可以使用强制类型转换：这个时候会得到另外一个警告，因为虚拟机中没有类型参数</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; result = (ArrayList&lt;Employee&gt;)employeeDB.<span class="builtin-name">find</span>(<span class="built_in">..</span><span class="built_in">..</span>);</span><br></pre></td></tr></table></figure><p>　　这个时候，如果确保不会造成严重的后果，可以使用@SuppressWarnings(“unchecked”)来标记这个变量能够接受类型转换：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">SuppressWarnings</span>("<span class="keyword">unchecked</span>")</span><br><span class="line"><span class="keyword">ArrayList</span>&lt;<span class="keyword">Employee</span>&gt; result = (ArrayList&lt;Employee&gt;)employeeDB.find(....);</span><br></pre></td></tr></table></figure><h2 id="挖坑"><a href="#挖坑" class="headerlink" title="挖坑"></a>挖坑</h2><ul><li>要永远记住浮点数的计算是会有误差，永远都无法精确，所以不要使用等于这个关系符</li><li>null的坑要填，判断的时候要永远记得空和长度为零都要同时写上。</li><li>非常小心可变对象的修改。’</li><li>类是类，对象是new，对象变量是引用</li></ul><p>疑惑</p><ul><li>声明类型未赋值后是Null，未声明类型是什么，内存的占用情况(未赋值时引用，占的时引用内存)</li><li>可变对象是什么</li><li>类初始化的执行顺序</li><li>类的搜索顺序</li><li>javadoc是否需要掌握使用</li><li>java.util和java.lang要新开一章</li><li>保护机制</li></ul><h2 id="奇怪的地方"><a href="#奇怪的地方" class="headerlink" title="奇怪的地方"></a>奇怪的地方</h2><p>class Employee {<br>public boolean equals(Employee other)<br> { return name.equals(other.name); }<br>}<br>if (harry,equals(boss))<br>方法可以访问所调用对象的私有数据。一个方法可以访问所属类的所有 对象的私有数据</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java基础知识&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://kodgv.xyz/categories/java/"/>
    
    
      <category term="java" scheme="http://kodgv.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>后端学习历程</title>
    <link href="http://kodgv.xyz/2019/04/30/JAVA%E5%AD%A6%E4%B9%A0/java%E5%8F%82%E8%80%83%E8%B7%AF%E7%BA%BF/"/>
    <id>http://kodgv.xyz/2019/04/30/JAVA学习/java参考路线/</id>
    <published>2019-04-30T11:30:59.000Z</published>
    <updated>2019-05-29T03:16:40.260Z</updated>
    
    <content type="html"><![CDATA[<p>java学习路线与推荐<br><a id="more"></a></p><h2 id="6个月-Java-服务端入门和进阶指南"><a href="#6个月-Java-服务端入门和进阶指南" class="headerlink" title="6个月 Java 服务端入门和进阶指南"></a>6个月 Java 服务端入门和进阶指南</h2><p><a href="https://www.zhihu.com/question/29581524" target="_blank" rel="noopener">https://www.zhihu.com/question/29581524</a><br><img src="/2019/04/30/JAVA学习/java参考路线/1" alt="1557919436614"></p><p><img src="/2019/04/30/JAVA学习/java参考路线/2" alt="1557919469076"></p><p><img src="/2019/04/30/JAVA学习/java参考路线/3" alt="1557919495443"></p><p>资料参考，先学第一阶段，学完再来看第二阶段的任务吧</p><p><a href="https://www.zhihu.com/question/22340525" target="_blank" rel="noopener">https://www.zhihu.com/question/22340525</a></p><p><a href="https://www.zhihu.com/question/307096748/answers/updated" target="_blank" rel="noopener">https://www.zhihu.com/question/307096748/answers/updated</a></p><p><a href="https://mp.weixin.qq.com/s/GxIRqj8s1zrnnPSOJ0203Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GxIRqj8s1zrnnPSOJ0203Q</a></p><p><a href="https://zhuanlan.zhihu.com/p/34880504" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34880504</a></p><p><a href="https://h2pl.github.io/" target="_blank" rel="noopener">后端校招以及大牛成长转折点</a></p><p><a href="https://www.nowcoder.com/discuss/16124" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/16124</a></p><p>知识点总结网站</p><p><a href="https://github.com/TransientWang/KnowledgeBase" target="_blank" rel="noopener">https://github.com/TransientWang/KnowledgeBase</a></p><p><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p><h2 id="自己整理"><a href="#自己整理" class="headerlink" title="自己整理"></a>自己整理</h2><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p><strong>JAVA基础的学习</strong></p><p>《Java 核心技术：卷1 基础知识》(或者《Java 编程思想》)必看</p><p>《Effective Java》</p><p>java.util包和java.lang包</p><p><a href="http://how2j.cn/" target="_blank" rel="noopener">做题网站</a></p><p><strong>代码规范</strong></p><p>《Git 权威指南》 <a href="https://link.zhihu.com/?target=https%3A//learngitbranching.js.org/" target="_blank" rel="noopener">Learn Git Branching通关网站</a></p><p>《Maven 实战》</p><p><a href="https://link.zhihu.com/?target=https%3A//book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构_改善既有代码的设计》</a></p><p>学习代码规范。我们大致上遵循 oracle 的 Java 语言编码规范，你可以先阅读并熟悉它。Code Formatting 文件在 git@xxx/coding-standard.git，在编写代码之前，请把它导入到 IDE 中。另外，确认 IDE 已经安装 Findbugs 和 CheckStyle 插件。</p><p><strong>开发工具</strong></p><ul><li>熟练使用一种 IDE。Intellij IDEA或者 Eclipse 都可以，推荐使用前者。至少熟悉常用的快捷键，会 debug(包括远程 debug)项目。</li><li>熟悉一种编辑器。比如 Vim/Emacs/Sublime Text，至少学会搜索/替换/代码补全。</li></ul><p><strong>开发环境</strong></p><p>Linux 的基本使用可以通过《鸟哥的Linux私房菜：基础学习篇（第三版）》学习</p><p> bash shell 脚本可以参考《Linux Shell脚本攻略》</p><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>刷题：</p><p>先从简单的图解算法看起，然后做题的时候不要做太多，做别人整理好的经典题比较重要。TopCoder，codeforces。然后注意题要抄在本子上，便于作弊，注意它们说的板子。</p><p>图解HTTP协议和servlet。再JAVA进阶，然后框架和数据库并行。</p><p>设计模式要优先于框架，这样才能更好掌握</p><p>需要掌握三大框架SSM，需要掌握各类数据库，需要掌握各类协议</p><p>设计模式</p><p>学Unix</p><p>基本的单元测试</p><p><strong>JAVA进阶</strong></p><ul><li><p><strong>《Java并发编程的艺术》《深入理解Java虚拟机》</strong></p></li><li><p>并发编程网：<strong>并发编程网 - ifeve.com</strong> 重点掌握java内存模型，各种锁的原理及应用，JVM GC垃圾回收原理。</p></li></ul><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>后端校招以及大牛成长转折点</p><p>源码</p><p>微服务</p><p>微架构</p><p>各种组件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java学习路线与推荐&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://kodgv.xyz/categories/java/"/>
    
    
      <category term="java" scheme="http://kodgv.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>比赛常用图</title>
    <link href="http://kodgv.xyz/2019/04/29/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/%E6%AF%94%E8%B5%9B%E5%B8%B8%E7%94%A8%E5%9B%BE/"/>
    <id>http://kodgv.xyz/2019/04/29/数据竞赛/比赛常用图/</id>
    <published>2019-04-29T08:30:12.000Z</published>
    <updated>2019-05-27T11:42:17.063Z</updated>
    
    <content type="html"><![CDATA[<p>比赛常见的EDA总结</p><a id="more"></a><p><strong>要注意把以后整理函数的时候把图补上</strong></p><p>plt.show()会阻碍当前程序的执行，请再最后执行<br>如果想要不阻碍请执行plt.ion()，但是这样当程序结束时会自动关闭当前图像，所以需要再最后执行plt.ioff()以阻碍图像不被关闭</p><p>[TOC]</p><h2 id="曲线分布图"><a href="#曲线分布图" class="headerlink" title="曲线分布图"></a>曲线分布图</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.kaggle.com/gpreda/santander-eda-and-prediction</span></span><br><span class="line">def plot_feature_distribution(df1, df2, label1, label2, features):</span><br><span class="line">    <span class="attr">i</span> = <span class="number">0</span></span><br><span class="line">    sns.set_style('whitegrid')</span><br><span class="line">    plt.figure()</span><br><span class="line">    fig, <span class="attr">ax</span> = plt.subplots(<span class="number">10</span>,<span class="number">10</span>,<span class="attr">figsize=(18,22))</span></span><br><span class="line"></span><br><span class="line">    for feature <span class="keyword">in</span> features:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        plt.subplot(<span class="number">10</span>,<span class="number">10</span>,i)</span><br><span class="line">        sns.distplot(df1[feature], <span class="attr">hist=False,label=label1)</span></span><br><span class="line">        sns.distplot(df2[feature], <span class="attr">hist=False,label=label2)</span></span><br><span class="line">        plt.xlabel(feature, <span class="attr">fontsize=9)</span></span><br><span class="line">        locs, <span class="attr">labels</span> = plt.xticks()</span><br><span class="line">        plt.tick_params(<span class="attr">axis='x',</span> <span class="attr">which='major',</span> <span class="attr">labelsize=6,</span> <span class="attr">pad=-6)</span></span><br><span class="line">        plt.tick_params(<span class="attr">axis='y',</span> <span class="attr">which='major',</span> <span class="attr">labelsize=6)</span></span><br><span class="line">    plt.show();</span><br><span class="line">    </span><br><span class="line"><span class="attr">t0</span> = train_df.loc[train_df['target'] == <span class="number">0</span>]</span><br><span class="line"><span class="attr">t1</span> = train_df.loc[train_df['target'] == <span class="number">1</span>]</span><br><span class="line"><span class="attr">features</span> = train_df.columns.values[<span class="number">2</span>:<span class="number">102</span>]</span><br><span class="line">plot_feature_distribution(t0, t1, '<span class="number">0</span>', '<span class="number">1</span>', features)</span><br></pre></td></tr></table></figure><p><img src="/2019/04/29/数据竞赛/比赛常用图/2.png" alt></p><h2 id="条形分布图"><a href="#条形分布图" class="headerlink" title="条形分布图"></a>条形分布图</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">6</span>))</span><br><span class="line">plt.<span class="built_in">title</span>(<span class="string">"Distribution of mean values per column in the train and test set"</span>)</span><br><span class="line">sns.distplot(train_df[<span class="built_in">features</span>].<span class="built_in">mean</span>(axis=<span class="number">0</span>),<span class="built_in">color</span>=<span class="string">"magenta"</span>,kde=True,bins=<span class="number">120</span>, <span class="built_in">label</span>='train')</span><br><span class="line">sns.distplot(test_df[<span class="built_in">features</span>].<span class="built_in">mean</span>(axis=<span class="number">0</span>),<span class="built_in">color</span>=<span class="string">"darkblue"</span>, kde=True,bins=<span class="number">120</span>, <span class="built_in">label</span>='test')</span><br><span class="line">plt.<span class="built_in">legend</span>()</span><br><span class="line">plt.<span class="built_in">show</span>()</span><br></pre></td></tr></table></figure><p><img src="/2019/04/29/数据竞赛/比赛常用图/3.png" alt></p><h2 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#画条形图</span></span><br><span class="line">sns.barplot<span class="params">(<span class="attr">x</span>='Sex', <span class="attr">y</span>='Survived', <span class="attr">data</span>=train)</span>;<span class="comment"># seaborn 的 barplot() 利用矩阵条的高度反映数值变量的集中趋势，展示的是变量的平均值</span></span><br><span class="line">sns.barplot<span class="params">(<span class="attr">x</span>='Sex', <span class="attr">y</span>='Survived', <span class="attr">hue</span> = 'Pclass', <span class="attr">data</span>=train)</span>;<span class="comment">#加了图例的功能</span></span><br></pre></td></tr></table></figure><h2 id="相关性热度图"><a href="#相关性热度图" class="headerlink" title="　相关性热度图"></a>　相关性热度图</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">colormap</span> = plt.cm.RdBu</span><br><span class="line">plt.figure(<span class="attr">figsize=(14,12))</span></span><br><span class="line">plt.title('Pearson Correlation of Features', <span class="attr">y=1.05,</span> <span class="attr">size=15)</span></span><br><span class="line">sns.heatmap(train.astype(float).corr(),<span class="attr">linewidths=0.1,vmax=1.0,</span> </span><br><span class="line">            <span class="attr">square=True,</span> <span class="attr">cmap=colormap,</span> <span class="attr">linecolor='white',</span> <span class="attr">annot=True)</span></span><br></pre></td></tr></table></figure><h2 id="多变量相关性图"><a href="#多变量相关性图" class="headerlink" title="　多变量相关性图"></a>　多变量相关性图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多变量相关性图 要注意哦这里的变量所有的成对一一对应的</span></span><br><span class="line">g = sns.pairplot(train[[<span class="string">u'Survived'</span>, <span class="string">u'Pclass'</span>, <span class="string">u'Sex'</span>, <span class="string">u'Age'</span>, <span class="string">u'Parch'</span>, <span class="string">u'Fare'</span>, <span class="string">u'Embarked'</span>,</span><br><span class="line">       <span class="string">u'FamilySize'</span>, <span class="string">u'Title'</span>]], hue=<span class="string">'Survived'</span>, palette = <span class="string">'seismic'</span>,size=<span class="number">1.2</span>,diag_kind = <span class="string">'kde'</span>,diag_kws=dict(shade=<span class="literal">True</span>),plot_kws=dict(s=<span class="number">10</span>) )</span><br></pre></td></tr></table></figure><h2 id="箱图"><a href="#箱图" class="headerlink" title="箱图"></a>箱图</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">''<span class="symbol">'Create</span> a <span class="keyword">function</span> <span class="keyword">to</span> count total outliers. <span class="keyword">And</span> plot variables <span class="keyword">with</span> <span class="keyword">and</span> without outliers.'''</span><br><span class="line">def outliers(<span class="keyword">variable</span>):</span><br><span class="line">    # Calculate <span class="number">1</span>st, <span class="number">3</span>rd quartiles <span class="keyword">and</span> iqr.</span><br><span class="line">    q1, q3 = <span class="keyword">variable</span>.quantile(<span class="number">0.25</span>), <span class="keyword">variable</span>.quantile(<span class="number">0.75</span>)</span><br><span class="line">    iqr = q3 - q1</span><br><span class="line">    </span><br><span class="line">    # Calculate lower fence <span class="keyword">and</span> upper fence <span class="keyword">for</span> outliers</span><br><span class="line">    l_fence, u_fence = q1 - <span class="number">1.5</span>*iqr , q3 + <span class="number">1.5</span>*iqr   # Any values less than l_fence <span class="keyword">and</span> greater than u_fence are outliers.</span><br><span class="line">    </span><br><span class="line">    # Observations that are outliers</span><br><span class="line">    outliers = <span class="keyword">variable</span>[(<span class="keyword">variable</span>&lt;l_fence) | (<span class="keyword">variable</span>&gt;u_fence)]</span><br><span class="line">    print(<span class="symbol">'Total</span> Outliers <span class="keyword">of</span>', <span class="keyword">variable</span>.name,':', outliers.count())</span><br><span class="line">    </span><br><span class="line">    # Drop obsevations that are outliers</span><br><span class="line">    filtered = <span class="keyword">variable</span>.drop(outliers.index, axis = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    # Create subplots</span><br><span class="line">    fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    # Gives space between two subplots</span><br><span class="line">    fig.subplots_adjust(hspace = <span class="number">1</span>) </span><br><span class="line">    </span><br><span class="line">    # Plot <span class="keyword">variable</span> <span class="keyword">with</span> outliers</span><br><span class="line">    <span class="keyword">variable</span>.plot.box(vert = <span class="literal">False</span>, color = <span class="symbol">'coral</span>', grid = <span class="literal">False</span>, ax = ax1, title = <span class="symbol">'Distribution</span> <span class="keyword">with</span> Outliers <span class="keyword">for</span> %s' %<span class="keyword">variable</span>.name)</span><br><span class="line"></span><br><span class="line">    # Plot <span class="keyword">variable</span> without outliers</span><br><span class="line">    filtered.plot.box(vert = <span class="literal">False</span>, color = <span class="symbol">'coral</span>', grid = <span class="literal">False</span>, ax = ax2, title = <span class="symbol">'Distribution</span> without Outliers <span class="keyword">for</span> %s' %<span class="keyword">variable</span>.name)</span><br></pre></td></tr></table></figure><h2 id="刻画变量的不平衡度"><a href="#刻画变量的不平衡度" class="headerlink" title="刻画变量的不平衡度"></a>刻画变量的不平衡度</h2><p>If skewness is less than −1 or greater than +1, the distribution can be considered as highly skewed.</p><p>If skewness is between −1 and −½ or between +½ and +1, the distribution can be considered as moderately skewed.</p><p>And finally if skewness is between −½ and +½, the distribution can be considered as approximately symmetric.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''#2.Density plot with skewness.'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">density_plot_and_skewness</span><span class="params">(variable)</span>:</span></span><br><span class="line">    variable.plot.hist(density = <span class="literal">True</span>)</span><br><span class="line">    variable.plot.kde(style = <span class="string">'k--'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'%s'</span>%variable.name)</span><br><span class="line">    plt.title(<span class="string">'Distribution of %s with Density Plot &amp; Histogram'</span> %variable.name)</span><br><span class="line">    print(<span class="string">'Skewness of '</span>, variable.name, <span class="string">':'</span>)</span><br><span class="line">    skewness = variable.skew()</span><br><span class="line">    <span class="keyword">return</span> display(skewness)</span><br></pre></td></tr></table></figure><h2 id="分类变量和分类变量的关系图"><a href="#分类变量和分类变量的关系图" class="headerlink" title="分类变量和分类变量的关系图"></a>分类变量和分类变量的关系图</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#############################<span class="number">2</span>X2列联表展示########################################</span><br><span class="line"><span class="string">''</span><span class="string">'#1.Create a function that calculates absolute and relative frequency of Survived variable by a categorical variable. And then plots the absolute and relative frequency of Survived by a categorical variable.'</span><span class="string">''</span></span><br><span class="line">def crosstab(cat, cat_target):</span><br><span class="line">    <span class="string">''</span><span class="string">'cat = categorical variable, cat_target = our target categorical variable.'</span><span class="string">''</span></span><br><span class="line">    global ax, ax1</span><br><span class="line">    cat_grouped_by_cat_target = pd.crosstab(index = cat, columns = cat_target)</span><br><span class="line">    cat_grouped_by_cat_target.rename(&#123;<span class="number">0</span>:<span class="string">'Victims'</span>, <span class="number">1</span>:<span class="string">'Survivors'</span>&#125;, axis = <span class="string">'columns'</span>, inplace = <span class="literal">True</span>)  # Renaming the columns</span><br><span class="line">    pct_cat_grouped_by_cat_target = round(pd.crosstab(index = cat, columns = cat_target, normalize = <span class="string">'index'</span>)*<span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line">    pct_cat_grouped_by_cat_target.rename(&#123;<span class="number">0</span>:<span class="string">'Victims(%)'</span>, <span class="number">1</span>:<span class="string">'Survivors(%)'</span>&#125;, axis = <span class="string">'columns'</span>, inplace = <span class="literal">True</span>)</span><br><span class="line">    print(<span class="string">'Survivals and Deaths by'</span>, cat.name,<span class="string">':'</span>, <span class="string">'\n'</span>,cat_grouped_by_cat_target )</span><br><span class="line">    print(<span class="string">'\nPercentage Survivals and Deaths by'</span>, cat.name, <span class="string">':'</span>,<span class="string">'\n'</span>, pct_cat_grouped_by_cat_target)</span><br><span class="line">    </span><br><span class="line">    # Plot absolute frequency <span class="keyword">of</span> Survived by a categorical variable</span><br><span class="line">    ax =  cat_grouped_by_cat_target.plot.bar(color = [<span class="string">'r'</span>, <span class="string">'g'</span>])</span><br><span class="line">    plt.title(<span class="string">'Survival vs Death Count by %s'</span> %cat.name)</span><br><span class="line">    abs_bar_labels()</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">    # Plot relative frequrncy <span class="keyword">of</span> Survived by a categorical variable</span><br><span class="line">    ax1 = pct_cat_grouped_by_cat_target.plot.bar(color = [<span class="string">'r'</span>, <span class="string">'g'</span>])</span><br><span class="line">    plt.title(<span class="string">'Percentage Survival vs Death Count by %s'</span> %cat.name)</span><br><span class="line">    pct_bar_labels()</span><br><span class="line">    plt.show()</span><br><span class="line">###########################################卡方检验#######################################</span><br><span class="line"><span class="string">''</span><span class="string">'#2.Create a function to calculate chi_square test between a categorical and target categorical variable.'</span><span class="string">''</span></span><br><span class="line">def chi_square(cat, cat_target):</span><br><span class="line">    cat_grouped_by_cat_target = pd.crosstab(index = cat, columns = cat_target)</span><br><span class="line">    test_result = stats.chi2_contingency (cat_grouped_by_cat_target)</span><br><span class="line">    print(<span class="string">'Chi_square test result between Survived &amp; %s'</span> %cat.name)</span><br><span class="line">    return display(test_result)</span><br><span class="line"></span><br><span class="line">#############################################bonferroni adjusted检验###############################</span><br><span class="line"><span class="string">''</span><span class="string">'#3.Finally create another function to calculate Bonferroni-adjusted pvalue for a categorical and target categorical variable.'</span><span class="string">''</span></span><br><span class="line">def bonferroni_adjusted(cat, cat_target):</span><br><span class="line">    dummies = pd.get_dummies(cat)</span><br><span class="line">    for columns <span class="keyword">in</span> dummies:</span><br><span class="line">        crosstab = pd.crosstab(dummies[columns], cat_target)</span><br><span class="line">        print(stats.chi2_contingency(crosstab))</span><br><span class="line">    print(<span class="string">'\nColumns:'</span>, dummies.columns)</span><br></pre></td></tr></table></figure><h2 id="多个变量组合对因变量的影响图"><a href="#多个变量组合对因变量的影响图" class="headerlink" title="多个变量组合对因变量的影响图"></a>多个变量组合对因变量的影响图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''Create a function that plots the impact of 3 predictor variables at a time on a target variable.'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multivariate_analysis</span><span class="params">(cat1, cat2, cat3, cat_target)</span>:</span></span><br><span class="line">    grouped = round(pd.crosstab(index = [cat1, cat2, cat3], columns = cat_target, normalize = <span class="string">'index'</span>)*<span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line">    grouped.rename(&#123;<span class="number">0</span>:<span class="string">'Died%'</span>, <span class="number">1</span>:<span class="string">'Survived%'</span>&#125;, axis = <span class="number">1</span>, inplace = <span class="literal">True</span>)</span><br><span class="line">    ax = grouped.plot.bar(color = [<span class="string">'r'</span>, <span class="string">'g'</span>])</span><br><span class="line">    plt.ylabel(<span class="string">'Relative Frequency (%)'</span>)</span><br></pre></td></tr></table></figure><h2 id="热度图"><a href="#热度图" class="headerlink" title="热度图"></a>热度图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https://www.kaggle.com/cdeotte/200-magical-models-santander-0-920</span></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sns.heatmap(x, cmap=<span class="string">'RdBu_r'</span>, center=<span class="number">0.0</span>) </span><br><span class="line">plt.title(<span class="string">'VAR_'</span>+str(j)+<span class="string">' Predictions without Magic'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.xticks(np.linspace(<span class="number">0</span>,<span class="number">49</span>,<span class="number">5</span>),np.round(np.linspace(mn,mx,<span class="number">5</span>),<span class="number">1</span>))</span><br><span class="line">plt.xlabel(<span class="string">'Var_'</span>+str(j))</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.ylabel(<span class="string">''</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2019/04/29/数据竞赛/比赛常用图/5.png" alt></p><p>通过热度图可以看出模型是否明显利用了两个特征。虽然可能特征重要度也会说明，但是这样的热度图明显会更具说服力，比如说var_0，模型可以得出竖线15，横线4之类的分界线。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛常见的EDA总结&lt;/p&gt;
    
    </summary>
    
      <category term="数据竞赛" scheme="http://kodgv.xyz/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="特征工程" scheme="http://kodgv.xyz/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="预处理" scheme="http://kodgv.xyz/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>迁移学习</title>
    <link href="http://kodgv.xyz/2019/04/29/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>http://kodgv.xyz/2019/04/29/数据竞赛/迁移学习/</id>
    <published>2019-04-29T07:56:28.000Z</published>
    <updated>2019-05-25T12:40:41.962Z</updated>
    
    <content type="html"><![CDATA[<p>待完善</p><a id="more"></a><p>！！！说不一定可以切分原数据集为新旧数据集</p><ul><li>新旧特征：新数据集为1，旧数据集为0</li><li>合并新旧数据：合并新旧来做特征处理然后有两种操作<br>第一种是用旧训练模型，用模型预测新数据集的train和test概率，然后加在后面做特征，然后在用新数据重新做特征处理然后预测（这个比较好）。 第二种是直接上新旧合并数据训练的模型，然后直接加模型概率做新特征（这个可能会leak，但是在目前的模板上有cv应该会好一点）然后在用新数据重新做特征处理然后预测</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;待完善&lt;/p&gt;
    
    </summary>
    
      <category term="数据竞赛" scheme="http://kodgv.xyz/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="特征工程" scheme="http://kodgv.xyz/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="机器学习" scheme="http://kodgv.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>去除重复值</title>
    <link href="http://kodgv.xyz/2019/04/29/%E7%AB%9E%E8%B5%9B%E7%BB%8F%E9%AA%8C/%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%80%BC/"/>
    <id>http://kodgv.xyz/2019/04/29/竞赛经验/去除重复值/</id>
    <published>2019-04-29T07:23:45.000Z</published>
    <updated>2019-05-27T11:44:21.037Z</updated>
    
    <content type="html"><![CDATA[<p>不去重的数据训练的模型 = 80%的非重复样本准确率 + 100%重复样本准确率<br>去重的数据训练的模型 = 85%的非重复样本准确率 + 85%重复样本准确率（直接规则覆盖后100%）<br>深度提取重复样本的真正目的是删除它们以提高模型预测非重复样本的准确率，非重复样本的准确率才是对业务有价值的</p><a id="more"></a><p><strong>1.Giba的home credit 里的重复样本</strong></p><p>如果八月份参加过kaggle的home credit比赛的一定知道，在最后一周才加入比赛的GM Giba通过丰富的比赛经验找到了重复样本trick帮助onodera队伍拿到了比赛的第二名，而另一位GM raddar在最后八个小时加入比赛就直接发现了重复样本问题，并solo到了45名。今天就先来分析一下他们的思路，<a href="https://link.zhihu.com/?target=https%3A//www.kaggle.com/raddar/a-competition-without-a-leak-or-is-it" target="_blank" rel="noopener">A competition without a leak. Or is it?</a></p><p>其实说起来简单，在home credit比赛里，每个客户都有多达两百列特征，但是人的基本特征是不会变的，性别、年龄、生日、银行开户时间等等。打个比方，尽管北京有三千万人，但是如果两样本同一天生日，同一天领驾照，办身份证，同一天结婚，同一天生娃，那么从统计上来说，这两样本肯定就是一个人，而不必再核对身高血型样貌了。radder 就是仅用[DAYS_BIRTH,DAYS_EMPLOYED,DAYS_REGISTRATION,DAYS_ID_PUBLISH,CODE_GENDER,REGION_POPULATION_RELATIVE]六个维度的特征，就把数据集里的重复样本给找出来了，其实其它两百列特征是否一样已经不重要了。</p><p><strong>小结</strong>：虽然我们在比赛里这个称之为trick，但背后是统计学意义的，也可以应用在工作之中。</p><p><strong>2.活学活用</strong></p><p>在我们最近参加的一个关于通讯用户套餐的比赛里，我们的GM piupiu也提到了这个trick。因为出题方把用户的流量消费精确到了byte，金钱消费精确到了分，通讯时间精确到了秒，所以如果用户A上月花了45.32元，用了1545MB 457kb 123byte的流量，打了78分12秒的电话，用户B上月也花了45.32元，用了1545MB 457kb 123byte的流量，打了78分12秒的电话，别管这家通讯公司用户量有多大，A和B肯定是同一用户。所以在其他队伍还在用给定的全部特征判定重复样本的时候，我们用八个特征就可以判定重复样本，把test里和train重复的样本给挑出来了。</p><p><strong>吐槽：</strong>因而我们得到了比其他队伍更多test里的重复样本，然后定义了白名单（piupiu的职业习惯）。在我们代码开源后有一小撮萌新看不懂我们的代码不说，还觉得是piupiu把竞赛网站黑了拿到test的label（滑稽）</p><p><strong>3.进阶</strong></p><p>有人会说了，拿到了test里的重复的样本的label，是不是可以上一波分了～～</p><p>答案是：<strong>并不能。</strong>因为xgb/lgb是具备非常强大的拟合能力，你不刻意找这些重复样本，xgb/lgb也能给你学出来，通过比较你会发现test里的重复样本已经全部给你预测对了。在home credit里是有重复用户的时序信息在里面可以利用，但是在我们这个比赛及大部分比赛就用不上了。</p><p>回到这个比赛，重复样本达到了全部数据的15%，test里的重复样本都预测对了，说明模型把train/test之间的重复样本的特性全学会了，有时候xgb/lgb学习能力太强也不是好事。这时候我们的GM piupiu提到了，test其实可以分为重复样本（15%）和非重复样本两部分（85%）来看待，真正对业务有意义的是非重复样本，可是所有参赛者却把重复样本过拟合的很好，我们真的目的应该是为出题方提供一个有效预测非重复样本的模型，因此提议我们应该把train里的重复样本去掉。打个比方，<strong>valid数据包含重复的和不重复两部分，不去重的数据训练的模型需要1000轮才能达到最优，去重的模型之后500轮最优，那说明有500轮是在过拟合重复样本，但这对于不重复样本来说是一个严重的过拟合，伤害了模型的泛化能力</strong>。而这个通讯比赛的重复样本达到了15%,对模型伤害很大。如果再根据包含重复样本的数据模型调参和特征工程，伤害就更大了。</p><p>简单的打个比方：</p><p>不去重的数据训练的模型 = 80%的非重复样本准确率 + 100%重复样本准确率</p><p>去重的数据训练的模型 = 85%的非重复样本准确率 + 85%重复样本准确率（直接规则覆盖后100%）</p><p>如果你要模型上线，你会上线哪个模型？</p><p>重复样本的准确率并不重要，无论是实际业务还是比赛，一个sql就搞定了。</p><p>根据piupiu的建议，于是我照着做了，果然模型变得特别稳定，也没有其他队伍所提到的抖动也消除了，提升的分数刚好是我们最后领先第二名的差距。</p><p>所以在这个比赛里，<strong>深度提取重复样本的真正目的是删除它们以提高模型预测非重复样本的准确率，非重复样本的准确率才是对业务有价值的。</strong></p><p>有些选手因为看到test里有重复样本就舍不得删的train里的重复样本，难道不用lgb预测的结果就不是结果了吗（流汗）</p><p><strong>小结：</strong>虽然第二节一直在说怎么更多的提取重复样本，但我们真正提升的是模型预测非重复样本的预测能力。</p><p><strong>吐槽：</strong>在我们代码开源后，有一小撮萌新看到我们在lgb输出的结果通过规则覆盖能上好多分，就觉得我们是在用重复样本的leak提升重复样本准确率，却不想想大家既然都能100%预测重复样本的情况下，差距在哪里…</p><p><strong>最后的吐槽：</strong>第一次代码开源就体会了当年plantgo开源携程代码的蛋疼。<a href="https://www.zhihu.com/question/64350623" target="_blank" rel="noopener">如何看待携程举办的大数据比赛？</a> 分享代码有一小撮萌新看不懂学不会清洗重复数据这种常规操作也就算了，还根据自己对代码自己的理解莫名其妙揣测，写本文章主要是帮助我们队友piupiu辟谣，顺便也给大家分享了点有价值的干货。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不去重的数据训练的模型 = 80%的非重复样本准确率 + 100%重复样本准确率&lt;br&gt;去重的数据训练的模型 = 85%的非重复样本准确率 + 85%重复样本准确率（直接规则覆盖后100%）&lt;br&gt;深度提取重复样本的真正目的是删除它们以提高模型预测非重复样本的准确率，非重复样本的准确率才是对业务有价值的&lt;/p&gt;
    
    </summary>
    
      <category term="竞赛经验" scheme="http://kodgv.xyz/categories/%E7%AB%9E%E8%B5%9B%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="特征工程" scheme="http://kodgv.xyz/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="机器学习" scheme="http://kodgv.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>异常值检测</title>
    <link href="http://kodgv.xyz/2019/04/29/%E7%AB%9E%E8%B5%9B%E7%BB%8F%E9%AA%8C/%E5%BC%82%E5%B8%B8%E5%80%BC%E6%A3%80%E6%B5%8B/"/>
    <id>http://kodgv.xyz/2019/04/29/竞赛经验/异常值检测/</id>
    <published>2019-04-29T07:12:19.000Z</published>
    <updated>2019-05-27T11:44:44.921Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/38066650" target="_blank" rel="noopener">https://www.zhihu.com/question/38066650</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/38066650&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/38066650&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="竞赛经验" scheme="http://kodgv.xyz/categories/%E7%AB%9E%E8%B5%9B%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="特征工程" scheme="http://kodgv.xyz/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="机器学习" scheme="http://kodgv.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>缺失值处理</title>
    <link href="http://kodgv.xyz/2019/04/29/%E7%AB%9E%E8%B5%9B%E7%BB%8F%E9%AA%8C/%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86/"/>
    <id>http://kodgv.xyz/2019/04/29/竞赛经验/缺失值处理/</id>
    <published>2019-04-29T02:52:21.000Z</published>
    <updated>2019-05-27T11:44:41.884Z</updated>
    
    <content type="html"><![CDATA[<p>数据缺失值处理</p><a id="more"></a><p>[TOC]</p><h2 id="数据丢失的原因。"><a href="#数据丢失的原因。" class="headerlink" title="数据丢失的原因。"></a>数据丢失的原因。</h2><ul><li><p>随机缺失(MAR):随机缺失意味着数据点缺失的倾向性与缺失的数据无关，而是与一些观察到的数据相关</p></li><li><p>完全随机缺失(MCAR):某个值缺失的事实与它的假设值以及其他变量的值无关。</p></li><li><p>非随机缺失(MNAR):两个可能的原因是,缺失值取决于假设的值(例如,工资高的人通常不愿透露他们的收入调查)或缺失值依赖于其他变量的值(例如假设女性一般不愿透露他们的年龄!此处年龄变量缺失值受性别变量影响)</p></li></ul><p>在前两种情况下，根据缺失值的出现情况删除缺失值的数据是安全的，而在第三种情况下，删除缺失值的观察值会在模型中产生偏差。所以在移除观测结果之前，我们必须非常小心。注意，归罪法不一定能给出更好的结果。</p><p><img src="/2019/04/29/竞赛经验/缺失值处理/1.png" alt></p><h4 id="删除"><a href="#删除" class="headerlink" title="　删除"></a>　删除</h4><p><strong>成列删除（listwise deletion）</strong></p><p>列表删除(完全案例分析)删除包含一个或多个缺失值的所有数据。特别是如果缺少的数据仅限于少量的观察，您可以选择从分析中删除这些情况。然而，在大多数情况下，使用列表删除通常是不利的。这是因为MCAR的假设(完全随机缺失)通常很少得到支持。因此，列表删除方法产生有偏差的参数和估计。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newdata &lt;- na.omit(mydata)</span><br><span class="line"><span class="comment"># In python</span></span><br><span class="line">mydata.dropna(<span class="attribute">inplace</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>成对删除（pairwise deletion）</strong></p><p>一般的备选方案，在进行多变量的联立时，只删除掉需要执行的变量的缺失数据。例如在ABC三个变量间，需要计算A和C的协方差，那么只有同时具备A/C的数据会被使用。</p><p>文献指出，当变量间的相关性普遍较低时，成对删除会产生更有效的估计值。然而当变量间的相关性较高时，建议还是使用成列删除。</p><p>理论上成对删除不建议作为成列删除的备选方案。</p><p><strong>虚拟变量调整（哑变量，dummy variables）</strong></p><p>新建两个变量，其中一个变量D为“是否缺失”，缺失值设为0，存在值设为1。</p><p>另一个变量X’，将缺失值设为c（可以是任何常数），存在值设为本身。</p><p>随后，对X’，D和其他变量（因变量和其他预设模型中的自变量）进行回归。这种调整的好处是它利用了所有可用的缺失数据的信息（是否缺失）。为了便利，一个好的c的设置方式是现有非缺失数据X的均数。</p><p>这样做的好处是，D的系数可以被解释成“在控制了其他变量的情况下，X具缺失数据的个体其Y的预测值减去具X平均数的个体于Y的预测值”</p><h4 id="Time-Series-Specific-Methods"><a href="#Time-Series-Specific-Methods" class="headerlink" title="Time-Series Specific Methods"></a>Time-Series Specific Methods</h4><p><strong>Last Observation Carried Forward (LOCF) &amp; Next Observation Carried Backward (NOCB)</strong></p><p><strong>Linear Interpolation</strong></p><p><strong>Seasonal Adjustment + Linear Interpolation</strong></p><h4 id="Mean-Median-and-Mode"><a href="#Mean-Median-and-Mode" class="headerlink" title="Mean, Median and Mode"></a>Mean, Median and Mode</h4><p>计算总体均值、中值或模态是一种非常基本的推算方法，但它没有利用时间序列特征，也没有使用变量之间的关系。它非常快，但有明显的缺点。缺点之一是平均输入减少了数据集中的方差。</p><h4 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h4><p>首先，使用相关矩阵标识值缺失的变量的几个预测器。在回归方程中，选取最优预测因子作为自变量。缺少数据的变量作为因变量。采用预测变量数据完整的案例生成回归方程;然后，该方程用于预测不完全情况下的缺失值。在迭代过程中，插入缺失变量的值，然后用所有的情况来预测因变量。重复这些步骤，直到预测值之间的差值很小，即它们收敛。</p><p>它“理论上”为缺失的值提供了很好的估计。然而，这种模式有几个缺点，往往超过了优点。首先，由于替换后的值是由其他变量预测的，它们往往“太好”地匹配在一起，因此标准误差被缩小了。我们还必须假设回归方程中使用的变量之间存在线性关系，而回归方程中可能没有线性关系。</p><h4 id="Multiple-Imputation"><a href="#Multiple-Imputation" class="headerlink" title="Multiple Imputation"></a>Multiple Imputation</h4><ol><li><strong>Imputation</strong>: Impute the missing entries of the incomplete data sets <em>m</em>times (<em>m</em>=3 in the figure). Note that imputed values are drawn from a distribution. Simulating random draws doesn’t include uncertainty in model parameters. Better approach is to use Markov Chain Monte Carlo (MCMC) simulation. This step results in m complete data sets.</li><li><strong>Analysis</strong>: Analyze each of the <em>m</em> completed data sets.</li><li><strong>Pooling</strong>: Integrate the <em>m</em> analysis results into a final result</li></ol><p><img src="/2019/04/29/竞赛经验/缺失值处理/2.png" alt></p><p>This is by far the most preferred method for imputation for the following reasons:</p><ul><li>Easy to use</li><li>No biases (if imputation model is correct)</li></ul><p>实现的代码包:fancyimpute</p><h4 id="Imputation-of-Categorical-Variables"><a href="#Imputation-of-Categorical-Variables" class="headerlink" title="Imputation of Categorical Variables"></a>Imputation of Categorical Variables</h4><p>把缺失的值作为一个类别进行填补</p><h4 id="KNN-K-Nearest-Neighbors"><a href="#KNN-K-Nearest-Neighbors" class="headerlink" title="KNN (K Nearest Neighbors)"></a>KNN (K Nearest Neighbors)</h4><p> XGBoost and Random Forest 同样也有 data imputation</p><p>该方法基于距离测度选取k个邻域，并以邻域的平均值作为估计的归一化方法。该方法需要选择最近邻的数目和距离度量。KNN既可以预测离散属性(k个近邻中最频繁的值)，也可以预测连续属性(k个近邻中均值)</p><p>距离度量根据数据的类型而变化:</p><ol><li><p>连续数据:连续数据常用的距离度量是欧式、Manhattan和cos</p></li><li><p>分类数据:本例中一般使用汉明距离。它接受所有的分类属性，如果两个点之间的值不相同，则对每个属性进行计数。然后，汉明距离等于值不同的属性的数量。</p></li></ol><p>KNN算法最吸引人的特点之一是易于理解和实现。KNN的非参数特性使其在某些数据可能非常“不寻常”的情况下具有优势。</p><p>KNN算法的一个明显缺点是，在分析大型数据集时非常耗时，因为它在整个数据集中搜索类似的实例。此外，由于最近邻和最近邻之间的距离相差不大，高维数据会严重降低KNN的精度</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据缺失值处理&lt;/p&gt;
    
    </summary>
    
      <category term="竞赛经验" scheme="http://kodgv.xyz/categories/%E7%AB%9E%E8%B5%9B%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="特征工程" scheme="http://kodgv.xyz/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="机器学习" scheme="http://kodgv.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>胶囊网络</title>
    <link href="http://kodgv.xyz/2019/04/27/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E8%83%B6%E5%9B%8A%E7%BD%91%E7%BB%9C/"/>
    <id>http://kodgv.xyz/2019/04/27/神经网络/胶囊网络/</id>
    <published>2019-04-27T08:30:18.000Z</published>
    <updated>2019-05-25T12:38:37.579Z</updated>
    
    <content type="html"><![CDATA[<p>胶囊网络</p><a id="more"></a><p>来源:<a href="https://spaces.ac.cn/archives/4819" target="_blank" rel="noopener">https://spaces.ac.cn/archives/4819</a></p><p>直接看上面的这个文章，描述的非常详细</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;胶囊网络&lt;/p&gt;
    
    </summary>
    
      <category term="神经网络" scheme="http://kodgv.xyz/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络结构" scheme="http://kodgv.xyz/tags/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FocalLoss针对不平衡数据</title>
    <link href="http://kodgv.xyz/2019/04/22/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/FocalLoss%E9%92%88%E5%AF%B9%E4%B8%8D%E5%B9%B3%E8%A1%A1%E6%95%B0%E6%8D%AE/"/>
    <id>http://kodgv.xyz/2019/04/22/神经网络/FocalLoss针对不平衡数据/</id>
    <published>2019-04-22T10:32:49.000Z</published>
    <updated>2019-05-25T12:37:58.417Z</updated>
    
    <content type="html"><![CDATA[<p>Focal loss 一种特别的损失函数，其特点为专注于那些无法分辨的样本</p><a id="more"></a><p>[TOC]</p><p>参考来源:</p><p><a href="https://zhuanlan.zhihu.com/p/32423092" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32423092</a></p><p><a href="https://www.zhihu.com/question/63581984" target="_blank" rel="noopener">https://www.zhihu.com/question/63581984</a></p><p><a href="https://zhuanlan.zhihu.com/p/28527749" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28527749</a></p><h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>​    本质上讲，Focal Loss 就是一个解决<strong>分类问题中类别不平衡、分类难度差异</strong>的一个 loss，总之这个工作一片好评就是了。大家还可以看知乎的讨论：<a href="https://www.zhihu.com/question/63581984" target="_blank" rel="noopener">如何评价 Kaiming 的 Focal Loss for Dense Object Detection？</a></p><p><strong>核心思想</strong></p><p>这样的做法就是：<strong>正样本的预测值大于 0.5 的，或者负样本的预测值小于 0.5 的，我都不更新了，把注意力集中在预测不准的那些样本，当然这个阈值可以调整。</strong>这样做能部分地达到目的，但是所需要的迭代次数会大大增加。</p><p>原因是这样的：以正样本为例，<strong>我只告诉模型正样本的预测值大于 0.5 就不更新了，却没有告诉它要“保持”大于 0.5</strong>，所以下一阶段，它的预测值就很有可能变回小于 0.5 了。当然，如果是这样的话，下一回合它又被更新了，这样反复迭代，理论上也能达到目的，但是迭代次数会大大增加。</p><p>所以，要想改进的话，重点就是<strong>“不只是要告诉模型正样本的预测值大于0.5就不更新了，而是要告诉模型当其大于0.5后就只需要保持就好了”</strong>。好比老师看到一个学生及格了就不管了，这显然是不行的。如果学生已经及格，那么应该要想办法要他保持目前这个状态甚至变得更好，而不是不管。</p><p>所以除了单纯的区分外，必须使该loss可导，这样才可以告诉模型。</p><p><strong>目的是通过减少易分类样本的权重，从而使得模型在训练时更专注于难分类的样本</strong>。</p><p>Kaiming 大神的 Focal Loss 形式是：</p><p><img src="/2019/04/22/神经网络/FocalLoss针对不平衡数据/f1.jpg" alt></p><p>如果落实到 <em>ŷ =σ(x)</em> 这个预测，那么就有：</p><p><img src="/2019/04/22/神经网络/FocalLoss针对不平衡数据/f3.jpg" alt="img"></p><p>特别地，<strong>如果</strong> <strong>K</strong> <strong>和</strong> <strong>γ</strong> <strong>都取 1，那么</strong> <strong>L∗∗=Lfl</strong>。</p><p>事实上 <em>K</em> 和 <em>γ</em> 的作用都是一样的，都是调节权重曲线的陡度，只是调节的方式不一样。注意<em>L∗∗</em>或 <em>Lfl</em> 实际上都已经包含了对不均衡样本的解决方法，或者说，类别不均衡本质上就是分类难度差异的体现。</p><p>​    首先y’的范围是0到1，所以不管γ是多少，这个调制系数都是大于等于0的。易分类的样本再多，你的权重很小，那么对于total loss的共享也就不会太大。那么怎么控制样本权重呢？举个例子，假设一个二分类，样本x1属于类别1的y’=0.9，样本x2属于类别1的y’=0.6，显然前者更可能是类别1，假设γ=1，那么对于y’=0.9，调制系数则为0.1；对于y’=0.6，调制系数则为0.4，这个调制系数就是这个样本对loss的贡献程度，也就是权重，所以难分的样本（pt=0.6）的权重更大。</p><p>​    <strong>比如负样本远比正样本多的话，模型肯定会倾向于数目多的负类（可以想象全部样本都判为负类），这时候，负类的</strong> <strong>*ŷ γ*</strong> <strong>或</strong> <strong>σ(Kx) 都很小，而正类的</strong> <strong>(1−ŷ )γ</strong> <strong>或</strong> <strong>*σ(−Kx)*</strong> <strong>就很大，这时候模型就会开始集中精力关注正样本。</strong></p><p>当然，Kaiming 大神还发现对 <em>Lfl</em> 做个权重调整，结果会有微小提升。</p><p><img src="/2019/04/22/神经网络/FocalLoss针对不平衡数据/f2.jpg" alt="img"></p><p>通过一系列调参，得到 <em>α=0.25, γ=2</em>（在他的模型上）的效果最好。注意在他的任务中，正样本是属于少数样本，也就是说，本来正样本难以“匹敌”负样本，但经过 <em>(1−ŷ )γ</em> 和 <em>ŷγ</em> 的“操控”后，也许形势还逆转了，还要对正样本降权。</p><p>不过我认为这样调整只是经验结果，理论上很难有一个指导方案来决定 <em>α</em> 的值，如果没有大算力调参，倒不如直接让 <em>α=0.5</em>（均等）。</p><h2 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a><strong>多分类</strong></h2><p>Focal Loss 在多分类中的形式也很容易得到，其实就是：</p><p><img src="/2019/04/22/神经网络/FocalLoss针对不平衡数据/f4.jpg" alt="img"></p><p><em>ŷt</em> 是目标的预测值，一般就是经过 softmax 后的结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>多分类</p><p><a href="https://github.com/marvis/pytorch-yolo2/blob/master/FocalLoss.py" target="_blank" rel="noopener">https://github.com/marvis/pytorch-yolo2/blob/master/FocalLoss.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FocalLoss</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">r"""</span></span><br><span class="line"><span class="string">        This criterion is a implemenation of Focal Loss, which is proposed in </span></span><br><span class="line"><span class="string">        Focal Loss for Dense Object Detection.</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">            Loss(x, class) = - \alpha (1-softmax(x)[class])^gamma \log(softmax(x)[class])</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        The losses are averaged across observations for each minibatch.</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            alpha(1D Tensor, Variable) : the scalar factor for this criterion</span></span><br><span class="line"><span class="string">            gamma(float, double) : gamma &gt; 0; reduces the relative loss for well-classiﬁed examples (p &gt; .5), </span></span><br><span class="line"><span class="string">                                   putting more focus on hard, misclassiﬁed examples</span></span><br><span class="line"><span class="string">            size_average(bool): size_average(bool): By default, the losses are averaged over observations for each minibatch.</span></span><br><span class="line"><span class="string">                                However, if the field size_average is set to False, the losses are</span></span><br><span class="line"><span class="string">                                instead summed for each minibatch.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, class_num, alpha=None, gamma=<span class="number">2</span>, size_average=True)</span>:</span></span><br><span class="line">        super(FocalLoss, self).__init__()</span><br><span class="line">        <span class="keyword">if</span> alpha <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.alpha = Variable(torch.ones(class_num, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(alpha, Variable):</span><br><span class="line">                self.alpha = alpha</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.alpha = Variable(alpha)</span><br><span class="line">        self.gamma = gamma</span><br><span class="line">        self.class_num = class_num</span><br><span class="line">        self.size_average = size_average</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs, targets)</span>:</span></span><br><span class="line">        N = inputs.size(<span class="number">0</span>)</span><br><span class="line">        print(N)</span><br><span class="line">        C = inputs.size(<span class="number">1</span>)</span><br><span class="line">        P = F.softmax(inputs)</span><br><span class="line"><span class="comment"># 这是为了获取onehot</span></span><br><span class="line">        class_mask = inputs.data.new(N, C).fill_(<span class="number">0</span>)</span><br><span class="line">        class_mask = Variable(class_mask)</span><br><span class="line">        ids = targets.view(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">        class_mask.scatter_(<span class="number">1</span>, ids.data, <span class="number">1.</span>)</span><br><span class="line">        <span class="comment">#print(class_mask)</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> inputs.is_cuda <span class="keyword">and</span> <span class="keyword">not</span> self.alpha.is_cuda:</span><br><span class="line">            self.alpha = self.alpha.cuda()</span><br><span class="line">        alpha = self.alpha[ids.data.view(<span class="number">-1</span>)]</span><br><span class="line">        </span><br><span class="line">        probs = (P*class_mask).sum(<span class="number">1</span>).view(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        log_p = probs.log()</span><br><span class="line">        <span class="comment">#print('probs size= &#123;&#125;'.format(probs.size()))</span></span><br><span class="line">        <span class="comment">#print(probs)</span></span><br><span class="line"></span><br><span class="line">        batch_loss = -alpha*(torch.pow((<span class="number">1</span>-probs), self.gamma))*log_p </span><br><span class="line">        <span class="comment">#print('-----bacth_loss------')</span></span><br><span class="line">        <span class="comment">#print(batch_loss)</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.size_average:</span><br><span class="line">            loss = batch_loss.mean()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            loss = batch_loss.sum()</span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    alpha = torch.rand(<span class="number">21</span>, <span class="number">1</span>)</span><br><span class="line">    print(alpha)</span><br><span class="line">    FL = FocalLoss(class_num=<span class="number">5</span>, gamma=<span class="number">0</span> )</span><br><span class="line">    CE = nn.CrossEntropyLoss()</span><br><span class="line">    N = <span class="number">4</span></span><br><span class="line">    C = <span class="number">5</span></span><br><span class="line">    inputs = torch.rand(N, C)</span><br><span class="line">    targets = torch.LongTensor(N).random_(C)</span><br><span class="line">    inputs_fl = Variable(inputs.clone(), requires_grad=<span class="literal">True</span>)</span><br><span class="line">    targets_fl = Variable(targets.clone())</span><br><span class="line"></span><br><span class="line">    inputs_ce = Variable(inputs.clone(), requires_grad=<span class="literal">True</span>)</span><br><span class="line">    targets_ce = Variable(targets.clone())</span><br><span class="line">    print(<span class="string">'----inputs----'</span>)</span><br><span class="line">    print(inputs)</span><br><span class="line">    print(<span class="string">'---target-----'</span>)</span><br><span class="line">    print(targets)</span><br><span class="line"></span><br><span class="line">    fl_loss = FL(inputs_fl, targets_fl)</span><br><span class="line">    ce_loss = CE(inputs_ce, targets_ce)</span><br><span class="line">    print(<span class="string">'ce = &#123;&#125;, fl =&#123;&#125;'</span>.format(ce_loss.data[<span class="number">0</span>], fl_loss.data[<span class="number">0</span>]))</span><br><span class="line">    fl_loss.backward()</span><br><span class="line">    ce_loss.backward()</span><br><span class="line">    <span class="comment">#print(inputs_fl.grad.data)</span></span><br><span class="line">    print(inputs_ce.grad.data)</span><br></pre></td></tr></table></figure><p>单分类</p><p><a href="https://www.kaggle.com/aakashnain/diving-deep-into-focal-loss" target="_blank" rel="noopener">https://www.kaggle.com/aakashnain/diving-deep-into-focal-loss</a></p><p><a href="https://www.kaggle.com/sfzero/focal-loss-feature-0-99994/comments" target="_blank" rel="noopener">https://www.kaggle.com/sfzero/focal-loss-feature-0-99994/comments</a></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">from torch import nn</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FocalLoss</span>(<span class="title">nn</span>.<span class="title">Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, alpha=<span class="number">1</span>, gamma=<span class="number">2</span>, logits=True, reduction=<span class="string">'elementwise_mean'</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">super</span>(FocalLoss, <span class="keyword">self</span>).__init_<span class="number">_</span>()</span><br><span class="line">        <span class="keyword">self</span>.alpha = alpha</span><br><span class="line">        <span class="keyword">self</span>.gamma = gamma</span><br><span class="line">        <span class="keyword">self</span>.logits = logits</span><br><span class="line">        <span class="keyword">self</span>.reduction = reduction</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(<span class="keyword">self</span>, inputs, targets)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">logits:</span></span><br><span class="line">            BCE_loss = F.binary_cross_entropy_with_logits(inputs, targets, reduction=<span class="string">'none'</span>)</span><br><span class="line">        <span class="symbol">else:</span></span><br><span class="line">            BCE_loss = F.binary_cross_entropy(inputs, targets, reduction=<span class="string">'none'</span>)</span><br><span class="line">        pt = torch.exp(-BCE_loss)</span><br><span class="line">        F_loss = <span class="keyword">self</span>.alpha * (<span class="number">1</span>-pt)**<span class="keyword">self</span>.gamma * BCE_loss</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.reduction is <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> F_loss</span><br><span class="line">        <span class="symbol">else:</span></span><br><span class="line">            <span class="keyword">return</span> torch.mean(F_loss)</span><br></pre></td></tr></table></figure><p>简单版代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.kaggle.com/c/santander-customer-transaction-prediction/discussion/83363#486607</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">staticWeightLoss</span><span class="params">(<span class="literal">true</span>,pred)</span></span><span class="symbol">:</span></span><br><span class="line">    loss = K.binary_crossentropy(<span class="literal">true</span>, pred)</span><br><span class="line">    positiveLoss = positiveWeights * loss</span><br><span class="line">    negativeLoss = negativeWeights * loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> K.switch(K.greater(<span class="literal">true</span>, <span class="number">0</span>.<span class="number">5</span>), positiveLoss, negativeLoss)</span><br></pre></td></tr></table></figure><p>!要注意softmax是要有两列以上，sigmod才是一列</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><p>这就是为什么之前别人做数据增强的时候，把预测很高的数据当作1把预测很低的数据当作0放进去加强训练。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Focal loss 一种特别的损失函数，其特点为专注于那些无法分辨的样本&lt;/p&gt;
    
    </summary>
    
      <category term="神经网络" scheme="http://kodgv.xyz/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="损失函数" scheme="http://kodgv.xyz/tags/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
